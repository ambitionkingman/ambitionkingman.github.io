<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Be a thoutghtfull programer,做一个有思想的程序猿。">
<meta property="og:type" content="website">
<meta property="og:title" content="Wuwei` Blog">
<meta property="og:url" content="https://github.com/ambitionkingman/index.html">
<meta property="og:site_name" content="Wuwei` Blog">
<meta property="og:description" content="Be a thoutghtfull programer,做一个有思想的程序猿。">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Wuwei` Blog">
<meta name="twitter:description" content="Be a thoutghtfull programer,做一个有思想的程序猿。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://github.com/ambitionkingman/"/>





  <title>Wuwei` Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wuwei` Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/resume/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            公益404
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/ambitionkingman/2018/03/14/http_post_type/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wu Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://p4ucv3uvl.bkt.clouddn.com/avatar/godnaruto.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wuwei` Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/14/http_post_type/" itemprop="url">POST 提交数据的四种</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-14T12:01:32+08:00">
                2018-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="POST-提交数据的四种方式"><a href="#POST-提交数据的四种方式" class="headerlink" title="POST 提交数据的四种方式"></a>POST 提交数据的四种方式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>&emsp;&emsp;HTTP/1.1 协议规定的 HTTP 请求方法有 OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE、CONNECT 这几种。其中 POST 一般用来向服务端提交数据。HTTP 协议是以 ASCII 码传输，建立在 TCP/IP 协议之上的应用层规范。规范把 HTTP 请求分为三个部分：状态行、请求头、消息主体。类似于下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;method&gt; &lt;request-URL&gt; &lt;version&gt;</span><br><span class="line">&lt;headers&gt;</span><br><span class="line"></span><br><span class="line">&lt;entity-body&gt;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp;协议规定 POST 提交的数据必须放在消息主体（entity-body）中，但协议并没有规定数据必须使用什么编码方式。实际上，开发者完全可以自己决定消息主体的格式，只要最后发送的 HTTP 请求满足上面的格式就可以。但是，数据发送出去，还要服务端解析成功才有意义。一般服务端语言如 java、php等，以及它们的 framework，都内置了自动解析常见数据格式的功能。服务端通常是根据请求头（headers）中的 Content-Type 字段来获知请求中的消息主体是用何种方式编码，再对主体进行解析。所以说到 POST 提交数据方案，包含了 Content-Type 和消息主体编码方式两部分。</p>
<h3 id="Content-Type-内容类型"><a href="#Content-Type-内容类型" class="headerlink" title="Content-Type 内容类型"></a>Content-Type 内容类型</h3><h4 id="1-application-x-www-form-urlencoded"><a href="#1-application-x-www-form-urlencoded" class="headerlink" title="1 application/x-www-form-urlencoded"></a>1 application/x-www-form-urlencoded</h4><p>&emsp;&emsp;浏览器的原生 <form> 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）：</form></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">POST http://www.example.com HTTP/1.1</span><br><span class="line">Content-Type: application/x-www-form-urlencoded;charset=utf-8</span><br><span class="line"></span><br><span class="line">title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。例如 java 中，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@PutMapping(&quot;/manufacturer&quot;)</span><br><span class="line">  public ResponseEntity updateManufacturer(Manufacturer manufacturer)&#123;</span><br><span class="line">      ResponseEntity check=manufacturerService.check(manufacturer, CrudType.UPDATE);</span><br><span class="line">      if(check instanceof SuccessResponseEntity)&#123;</span><br><span class="line">          return manufacturerService.updateManufacturer(manufacturer);</span><br><span class="line">      &#125;</span><br><span class="line">      return check;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp; 请求的的参数为实体对象则可以直接序列化成为对象。（对有些中间层验证等其他框架支持不是很好）,很多时候，我们用 Ajax 提交数据时，也是使用这种方式。例如 JQuery 和 QWrap 的 Ajax，Content-Type 默认值都是「application/x-www-form-urlencoded;charset=utf-8」。</p>
<h4 id="2-multipart-form-data"><a href="#2-multipart-form-data" class="headerlink" title="2 multipart/form-data"></a>2 multipart/form-data</h4><p>&emsp;&emsp;我们使用表单上传文件时，必须让 <form> 表单的 enctype 等于 multipart/form-data。示例：</form></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">POST http://www.example.com HTTP/1.1</span><br><span class="line">Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name=&quot;text&quot;</span><br><span class="line"></span><br><span class="line">title</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;</span><br><span class="line">Content-Type: image/png</span><br><span class="line"></span><br><span class="line">PNG ... content of chrome.png ...</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 –boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。</p>
<p>&emsp;&emsp;这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 <form> 表单也只支持这两种方式（通过 <form> 元素的 enctype 属性指定，默认为 application/x-www-form-urlencoded。其实 enctype 还支持 text/plain，不过用得非常少）。随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。</form></form></p>
<h4 id="3-application-json"><a href="#3-application-json" class="headerlink" title="3 application/json"></a>3 application/json</h4><p>&emsp;&emsp;application/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。</p>
<p>&emsp;&emsp;JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。记得我几年前做一个项目时，需要提交的数据层次非常深，我就是把数据 JSON 序列化之后来提交的。不过当时我是把 JSON 字符串作为 val，仍然放在键值对里，以 x-www-form-urlencoded 方式提交。</p>
<p>Google 的 AngularJS 中的 Ajax 功能，默认就是提交 JSON 字符串。例如下面这段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JS</span><br><span class="line">var data = &#123;&apos;title&apos;:&apos;test&apos;, &apos;sub&apos; : [1,2,3]&#125;;</span><br><span class="line">$http.post(url, data).success(function(result) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>最终发送的请求是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BASH</span><br><span class="line">POST http://www.example.com HTTP/1.1</span><br><span class="line">Content-Type: application/json;charset=utf-8</span><br><span class="line"></span><br><span class="line">&#123;&quot;title&quot;:&quot;test&quot;,&quot;sub&quot;:[1,2,3]&#125;</span><br></pre></td></tr></table></figure></p>
<p>&emsp;&emsp; 这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好.<br>例如：java中这样使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@PutMapping(&quot;/manufacturer&quot;)</span><br><span class="line">public ResponseEntity updateManufacturer(@RequestBody @Validated Manufacturer manufacturer)&#123;</span><br><span class="line">    ResponseEntity check=manufacturerService.check(manufacturer, CrudType.UPDATE);</span><br><span class="line">    if(check instanceof SuccessResponseEntity)&#123;</span><br><span class="line">        return manufacturerService.updateManufacturer(manufacturer);</span><br><span class="line">    &#125;</span><br><span class="line">    return check;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;<br>当然 AngularJS 也可以配置为使用 x-www-form-urlencoded 方式提交数据。如有需要，可以参考这篇文章。</p>
<h4 id="4-text-xml"><a href="#4-text-xml" class="headerlink" title="4 text/xml"></a>4 text/xml</h4><p> XML-RPC（XML Remote Procedure Call）。这是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范。典型的 XML-RPC 请求是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTML</span><br><span class="line">POST http://www.example.com HTTP/1.1</span><br><span class="line">Content-Type: text/xml</span><br><span class="line"></span><br><span class="line">&lt;?xml version=&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;methodCall&gt;</span><br><span class="line">    &lt;methodName&gt;examples.getStateName&lt;/methodName&gt;</span><br><span class="line">    &lt;params&gt;</span><br><span class="line">        &lt;param&gt;</span><br><span class="line">            &lt;value&gt;&lt;i4&gt;41&lt;/i4&gt;&lt;/value&gt;</span><br><span class="line">        &lt;/param&gt;</span><br><span class="line">    &lt;/params&gt;</span><br><span class="line">&lt;/methodCall&gt;</span><br></pre></td></tr></table></figure>
<p>&emsp;&emsp;XML-RPC 协议简单、功能够用，各种语言的实现都有。它的使用也很广泛，如 WordPress 的 XML-RPC Api，搜索引擎的 ping 服务等等。JavaScript 中，也有现成的库支持以这种方式进行数据交互，能很好的支持已有的 XML-RPC 服务。不过，我个人觉得 XML 结构还是过于臃肿，一般场景用 JSON 会更灵活方便。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/ambitionkingman/2018/03/14/axios/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wu Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://p4ucv3uvl.bkt.clouddn.com/avatar/godnaruto.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wuwei` Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/14/axios/" itemprop="url">axios</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-14T10:50:05+08:00">
                2018-03-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h1><p><a href="https://www.npmjs.com/package/axios" target="_blank" rel="noopener">官方网站</a></p>
<p><img src="https://img.shields.io/npm/v/axios.svg?style=flat-square" alt="npm version"></p>
<p><img src="https://img.shields.io/travis/axios/axios.svg?style=flat-square" alt="build status"></p>
<p><img src="https://img.shields.io/coveralls/mzabriskie/axios.svg?style=flat-square" alt="code coverage"></p>
<h2 id="官方中文简介"><a href="#官方中文简介" class="headerlink" title="官方中文简介"></a>官方中文简介</h2><h3 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h3><ul>
<li>从浏览器中创建 XMLHttpRequests</li>
<li>从 node.js 创建 http 请求</li>
<li>支持 Promise API</li>
<li>拦截请求和响应</li>
<li>转换请求数据和响应数据</li>
<li>取消请求-</li>
<li>自动转换 JSON 数据</li>
<li>客户端支持防御 XSRF</li>
</ul>
<h3 id="Browser-Support"><a href="#Browser-Support" class="headerlink" title="Browser Support"></a>Browser Support</h3><p><img src="https://saucelabs.com/open_sauce/build_matrix/axios.svg" alt="浏览器支持"></p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><blockquote>
<p>执行 GET 请求</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">// 为给定 ID 的 user 创建请求</span><br><span class="line">axios.get(&apos;/user?ID=12345&apos;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">// 可选地，上面的请求可以这样做</span><br><span class="line">axios.get(&apos;/user&apos;, &#123;</span><br><span class="line">    params: &#123;</span><br><span class="line">      ID: 12345</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">执行 POST 请求</span><br><span class="line"></span><br><span class="line">axios.post(&apos;/user&apos;, &#123;</span><br><span class="line">    firstName: &apos;Fred&apos;,</span><br><span class="line">    lastName: &apos;Flintstone&apos;</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(function (response) &#123;</span><br><span class="line">    console.log(response);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    console.log(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>执行多个并发请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function getUserAccount() &#123;</span><br><span class="line">  return axios.get(&apos;/user/12345&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function getUserPermissions() &#123;</span><br><span class="line">  return axios.get(&apos;/user/12345/permissions&apos;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">axios.all([getUserAccount(), getUserPermissions()])</span><br><span class="line">  .then(axios.spread(function (acct, perms) &#123;</span><br><span class="line">    // 两个请求现在都执行完成</span><br><span class="line">  &#125;));</span><br></pre></td></tr></table></figure></p>
<h3 id="axios-API"><a href="#axios-API" class="headerlink" title="axios API"></a>axios API</h3><p>可以通过向 axios 传递相关配置来创建请求<br>axios(config)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 发送 POST 请求</span><br><span class="line">axios(&#123;</span><br><span class="line">  method: &apos;post&apos;,</span><br><span class="line">  url: &apos;/user/12345&apos;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Fred&apos;,</span><br><span class="line">    lastName: &apos;Flintstone&apos;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">axios(url[, config])</span><br><span class="line"></span><br><span class="line">// 发送 GET 请求（默认的方法）</span><br><span class="line">axios(&apos;/user/12345&apos;);</span><br></pre></td></tr></table></figure></p>
<h3 id="请求方法的别名"><a href="#请求方法的别名" class="headerlink" title="请求方法的别名"></a>请求方法的别名</h3><ul>
<li>为方便起见，为所有支持的请求方法提供了别名</li>
<li>axios.request(config)</li>
<li>axios.get(url[, config])</li>
<li>axios.delete(url[, config])</li>
<li>axios.head(url[, config])</li>
<li>axios.post(url[, data[, config]])</li>
<li>axios.put(url[, data[, config]])</li>
<li>axios.patch(url[, data[, config]])</li>
</ul>
<h5 id="NOTE"><a href="#NOTE" class="headerlink" title="NOTE"></a>NOTE</h5><p>在使用别名方法时， url、method、data 这些属性都不必在配置中指定。<br>并发处理并发请求的助手函数</p>
<ul>
<li>axios.all(iterable)</li>
<li>axios.spread(callback)<h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3></li>
</ul>
<p>可以使用自定义配置新建一个 axios 实例</p>
<ul>
<li>axios.create([config])<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var instance = axios.create(&#123;</span><br><span class="line">  baseURL: &apos;https://some-domain.com/api/&apos;,</span><br><span class="line">  timeout: 1000,</span><br><span class="line">  headers: &#123;&apos;X-Custom-Header&apos;: &apos;foobar&apos;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>实例方法</p>
<p>以下是可用的实例方法。指定的配置将与实例的配置合并</p>
<ul>
<li>axios#request(config)</li>
<li>axios#get(url[, config])</li>
<li>axios#delete(url[, config])</li>
<li>axios#head(url[, config])</li>
<li>axios#post(url[, data[, config]])</li>
<li>axios#put(url[, data[, config]])</li>
<li>axios#patch(url[, data[, config]])</li>
</ul>
<p>请求配置<br>这些是创建请求时可以用的配置选项。只有 url 是必需的。如果没有指定 method，请求将默认使用 get 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // `url` 是用于请求的服务器 URL</span><br><span class="line">  url: &apos;/user&apos;,</span><br><span class="line"></span><br><span class="line">  // `method` 是创建请求时使用的方法</span><br><span class="line">  method: &apos;get&apos;, // 默认是 get</span><br><span class="line"></span><br><span class="line">  // `baseURL` 将自动加在 `url` 前面，除非 `url` 是一个绝对 URL。</span><br><span class="line">  // 它可以通过设置一个 `baseURL` 便于为 axios 实例的方法传递相对 URL</span><br><span class="line">  baseURL: &apos;https://some-domain.com/api/&apos;,</span><br><span class="line"></span><br><span class="line">  // `transformRequest` 允许在向服务器发送前，修改请求数据</span><br><span class="line">  // 只能用在 &apos;PUT&apos;, &apos;POST&apos; 和 &apos;PATCH&apos; 这几个请求方法</span><br><span class="line">  // 后面数组中的函数必须返回一个字符串，或 ArrayBuffer，或 Stream</span><br><span class="line">  transformRequest: [function (data) &#123;</span><br><span class="line">    // 对 data 进行任意转换处理</span><br><span class="line"></span><br><span class="line">    return data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  // `transformResponse` 在传递给 then/catch 前，允许修改响应数据</span><br><span class="line">  transformResponse: [function (data) &#123;</span><br><span class="line">    // 对 data 进行任意转换处理</span><br><span class="line"></span><br><span class="line">    return data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  // `headers` 是即将被发送的自定义请求头</span><br><span class="line">  headers: &#123;&apos;X-Requested-With&apos;: &apos;XMLHttpRequest&apos;&#125;,</span><br><span class="line"></span><br><span class="line">  // `params` 是即将与请求一起发送的 URL 参数</span><br><span class="line">  // 必须是一个无格式对象(plain object)或 URLSearchParams 对象</span><br><span class="line">  params: &#123;</span><br><span class="line">    ID: 12345</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // `paramsSerializer` 是一个负责 `params` 序列化的函数</span><br><span class="line">  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span><br><span class="line">  paramsSerializer: function(params) &#123;</span><br><span class="line">    return Qs.stringify(params, &#123;arrayFormat: &apos;brackets&apos;&#125;)</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // `data` 是作为请求主体被发送的数据</span><br><span class="line">  // 只适用于这些请求方法 &apos;PUT&apos;, &apos;POST&apos;, 和 &apos;PATCH&apos;</span><br><span class="line">  // 在没有设置 `transformRequest` 时，必须是以下类型之一：</span><br><span class="line">  // - string, plain object, ArrayBuffer, ArrayBufferView, URLSearchParams</span><br><span class="line">  // - 浏览器专属：FormData, File, Blob</span><br><span class="line">  // - Node 专属： Stream</span><br><span class="line">  data: &#123;</span><br><span class="line">    firstName: &apos;Fred&apos;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // `timeout` 指定请求超时的毫秒数(0 表示无超时时间)</span><br><span class="line">  // 如果请求话费了超过 `timeout` 的时间，请求将被中断</span><br><span class="line">  timeout: 1000,</span><br><span class="line"></span><br><span class="line">  // `withCredentials` 表示跨域请求时是否需要使用凭证</span><br><span class="line">  withCredentials: false, // 默认的</span><br><span class="line"></span><br><span class="line">  // `adapter` 允许自定义处理请求，以使测试更轻松</span><br><span class="line">  // 返回一个 promise 并应用一个有效的响应 (查阅 [response docs](#response-api)).</span><br><span class="line">  adapter: function (config) &#123;</span><br><span class="line">    /* ... */</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // `auth` 表示应该使用 HTTP 基础验证，并提供凭据</span><br><span class="line">  // 这将设置一个 `Authorization` 头，覆写掉现有的任意使用 `headers` 设置的自定义 `Authorization`头</span><br><span class="line">  auth: &#123;</span><br><span class="line">    username: &apos;janedoe&apos;,</span><br><span class="line">    password: &apos;s00pers3cret&apos;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // `responseType` 表示服务器响应的数据类型，可以是 &apos;arraybuffer&apos;, &apos;blob&apos;, &apos;document&apos;, &apos;json&apos;, &apos;text&apos;, &apos;stream&apos;</span><br><span class="line">  responseType: &apos;json&apos;, // 默认的</span><br><span class="line"></span><br><span class="line">  // `xsrfCookieName` 是用作 xsrf token 的值的cookie的名称</span><br><span class="line">  xsrfCookieName: &apos;XSRF-TOKEN&apos;, // default</span><br><span class="line"></span><br><span class="line">  // `xsrfHeaderName` 是承载 xsrf token 的值的 HTTP 头的名称</span><br><span class="line">  xsrfHeaderName: &apos;X-XSRF-TOKEN&apos;, // 默认的</span><br><span class="line"></span><br><span class="line">  // `onUploadProgress` 允许为上传处理进度事件</span><br><span class="line">  onUploadProgress: function (progressEvent) &#123;</span><br><span class="line">    // 对原生进度事件的处理</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // `onDownloadProgress` 允许为下载处理进度事件</span><br><span class="line">  onDownloadProgress: function (progressEvent) &#123;</span><br><span class="line">    // 对原生进度事件的处理</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // `maxContentLength` 定义允许的响应内容的最大尺寸</span><br><span class="line">  maxContentLength: 2000,</span><br><span class="line"></span><br><span class="line">  // `validateStatus` 定义对于给定的HTTP 响应状态码是 resolve 或 reject  promise 。如果 `validateStatus` 返回 `true` (或者设置为 `null` 或 `undefined`)，promise 将被 resolve; 否则，promise 将被 rejecte</span><br><span class="line">  validateStatus: function (status) &#123;</span><br><span class="line">    return status &gt;= 200 &amp;&amp; status &lt; 300; // 默认的</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // `maxRedirects` 定义在 node.js 中 follow 的最大重定向数目</span><br><span class="line">  // 如果设置为0，将不会 follow 任何重定向</span><br><span class="line">  maxRedirects: 5, // 默认的</span><br><span class="line"></span><br><span class="line">  // `httpAgent` 和 `httpsAgent` 分别在 node.js 中用于定义在执行 http 和 https 时使用的自定义代理。允许像这样配置选项：</span><br><span class="line">  // `keepAlive` 默认没有启用</span><br><span class="line">  httpAgent: new http.Agent(&#123; keepAlive: true &#125;),</span><br><span class="line">  httpsAgent: new https.Agent(&#123; keepAlive: true &#125;),</span><br><span class="line"></span><br><span class="line">  // &apos;proxy&apos; 定义代理服务器的主机名称和端口</span><br><span class="line">  // `auth` 表示 HTTP 基础验证应当用于连接代理，并提供凭据</span><br><span class="line">  // 这将会设置一个 `Proxy-Authorization` 头，覆写掉已有的通过使用 `header` 设置的自定义 `Proxy-Authorization` 头。</span><br><span class="line">  proxy: &#123;</span><br><span class="line">    host: &apos;127.0.0.1&apos;,</span><br><span class="line">    port: 9000,</span><br><span class="line">    auth: : &#123;</span><br><span class="line">      username: &apos;mikeymike&apos;,</span><br><span class="line">      password: &apos;rapunz3l&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  // `cancelToken` 指定用于取消请求的 cancel token</span><br><span class="line">  // （查看后面的 Cancellation 这节了解更多）</span><br><span class="line">  cancelToken: new CancelToken(function (cancel) &#123;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h3><p>某个请求的响应包含以下信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // `data` 由服务器提供的响应</span><br><span class="line">  data: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  // `status` 来自服务器响应的 HTTP 状态码</span><br><span class="line">  status: 200,</span><br><span class="line"></span><br><span class="line">  // `statusText` 来自服务器响应的 HTTP 状态信息</span><br><span class="line">  statusText: &apos;OK&apos;,</span><br><span class="line"></span><br><span class="line">  // `headers` 服务器响应的头</span><br><span class="line">  headers: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  // `config` 是为请求提供的配置信息</span><br><span class="line">  config: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 then 时，你将接收下面这样的响应：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&apos;/user/12345&apos;)</span><br><span class="line">  .then(function(response) &#123;</span><br><span class="line">    console.log(response.data);</span><br><span class="line">    console.log(response.status);</span><br><span class="line">    console.log(response.statusText);</span><br><span class="line">    console.log(response.headers);</span><br><span class="line">    console.log(response.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<p>在使用 catch 时，或传递 rejection callback 作为 then 的第二个参数时，响应可以通过 error 对象可被使用，正如在错误处理这一节所讲。<br>配置的默认值/defaults</p>
<p>你可以指定将被用在各个请求的配置默认值<br>全局的 axios 默认值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL = &apos;https://api.example.com&apos;;</span><br><span class="line">axios.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;</span><br><span class="line">axios.defaults.headers.post[&apos;Content-Type&apos;] = &apos;application/x-www-form-urlencoded&apos;;</span><br><span class="line"></span><br><span class="line">自定义实例默认值</span><br><span class="line"></span><br><span class="line">// 创建实例时设置配置的默认值</span><br><span class="line">var instance = axios.create(&#123;</span><br><span class="line">  baseURL: &apos;https://api.example.com&apos;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 在实例已创建后修改默认值</span><br><span class="line">instance.defaults.headers.common[&apos;Authorization&apos;] = AUTH_TOKEN;</span><br></pre></td></tr></table></figure></p>
<h3 id="配置的优先顺序"><a href="#配置的优先顺序" class="headerlink" title="配置的优先顺序"></a>配置的优先顺序</h3><p>配置会以一个优先顺序进行合并。这个顺序是：在 lib/defaults.js 找到的库的默认值，然后是实例的 defaults 属性，最后是请求的 config 参数。后者将优先于前者。这里是一个例子：</p>
<p>// 使用由库提供的配置的默认值来创建实例<br>// 此时超时配置的默认值是 <code>0</code><br>var instance = axios.create();</p>
<p>// 覆写库的超时默认值<br>// 现在，在超时前，所有请求都会等待 2.5 秒<br>instance.defaults.timeout = 2500;</p>
<p>// 为已知需要花费很长时间的请求覆写超时设置<br>instance.get(‘/longRequest’, {<br>  timeout: 5000<br>});</p>
<h3 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h3><p>在请求或响应被 then 或 catch 处理前拦截它们。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 添加请求拦截器</span><br><span class="line">axios.interceptors.request.use(function (config) &#123;</span><br><span class="line">    // 在发送请求之前做些什么</span><br><span class="line">    return config;</span><br><span class="line">  &#125;, function (error) &#123;</span><br><span class="line">    // 对请求错误做些什么</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">// 添加响应拦截器</span><br><span class="line">axios.interceptors.response.use(function (response) &#123;</span><br><span class="line">    // 对响应数据做点什么</span><br><span class="line">    return response;</span><br><span class="line">  &#125;, function (error) &#123;</span><br><span class="line">    // 对响应错误做点什么</span><br><span class="line">    return Promise.reject(error);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果你想在稍后移除拦截器，可以这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var myInterceptor = axios.interceptors.request.use(function () &#123;/*...*/&#125;);</span><br><span class="line">axios.interceptors.request.eject(myInterceptor);</span><br></pre></td></tr></table></figure></p>
<p>可以为自定义 axios 实例添加拦截器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var instance = axios.create();</span><br><span class="line">instance.interceptors.request.use(function () &#123;/*...*/&#125;);</span><br></pre></td></tr></table></figure></p>
<p>错误处理<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&apos;/user/12345&apos;)</span><br><span class="line">  .catch(function (error) &#123;</span><br><span class="line">    if (error.response) &#123;</span><br><span class="line">      // 请求已发出，但服务器响应的状态码不在 2xx 范围内</span><br><span class="line">      console.log(error.response.data);</span><br><span class="line">      console.log(error.response.status);</span><br><span class="line">      console.log(error.response.headers);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Something happened in setting up the request that triggered an Error</span><br><span class="line">      console.log(&apos;Error&apos;, error.message);</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(error.config);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure></p>
<p>可以使用 validateStatus 配置选项定义一个自定义 HTTP 状态码的错误范围。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">axios.get(&apos;/user/12345&apos;, &#123;</span><br><span class="line">  validateStatus: function (status) &#123;</span><br><span class="line">    return status &lt; 500; // 状态码在大于或等于500时才会 reject</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>取消</p>
<p>使用 cancel token 取消请求</p>
<pre><code>Axios 的 cancel token API 基于cancelable promises proposal，它还处于第一阶段。
</code></pre><p>可以使用 CancelToken.source 工厂方法创建 cancel token，像这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var CancelToken = axios.CancelToken;</span><br><span class="line">var source = CancelToken.source();</span><br><span class="line"></span><br><span class="line">axios.get(&apos;/user/12345&apos;, &#123;</span><br><span class="line">  cancelToken: source.token</span><br><span class="line">&#125;).catch(function(thrown) &#123;</span><br><span class="line">  if (axios.isCancel(thrown)) &#123;</span><br><span class="line">    console.log(&apos;Request canceled&apos;, thrown.message);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 处理错误</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>// 取消请求（message 参数是可选的）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source.cancel(&apos;Operation canceled by the user.&apos;);</span><br></pre></td></tr></table></figure></p>
<p>还可以通过传递一个 executor 函数到 CancelToken 的构造函数来创建 cancel token：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var CancelToken = axios.CancelToken;</span><br><span class="line">var cancel;</span><br><span class="line"></span><br><span class="line">axios.get(&apos;/user/12345&apos;, &#123;</span><br><span class="line">  cancelToken: new CancelToken(function executor(c) &#123;</span><br><span class="line">    // executor 函数接收一个 cancel 函数作为参数</span><br><span class="line">    cancel = c;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// 取消请求</span><br><span class="line">cancel();</span><br></pre></td></tr></table></figure></p>
<h4 id="Note"><a href="#Note" class="headerlink" title="Note :"></a>Note :</h4><p>可以使用同一个 cancel token 取消多个请求<br>axios 依赖原生的 ES6 Promise 实现而被支持.<br>如果你的环境不支持 ES6 Promise，你可以使用 polyfill.<br>TypeScript.</p>
<hr>
<h2 id="项目中遇到的坑"><a href="#项目中遇到的坑" class="headerlink" title="项目中遇到的坑"></a>项目中遇到的坑</h2><blockquote>
<p>使用默认的 axios 配置</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var  service=axios.create(&#123;</span><br><span class="line">  baseURL: &apos;http://127.0.0.1:8080/test&apos;, // api的base_url</span><br><span class="line">  timeout: 5000,                  // 请求超时时间</span><br><span class="line">  transformRequest: [function (data, headers) &#123;</span><br><span class="line"></span><br><span class="line">      // 这里可以在发送请求之前对请求数据做处理，比如form-data格式化等，这里可以使用开头引入的Qs（这个模块在安装axios的时候就已经安装了，不需要另外安装）</span><br><span class="line">      //这里封装的参数为u表单提交参数，也就是username=admin&amp;password=000000这种只能怪类型。提交类型为：application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">    data = Qs.stringify(data)</span><br><span class="line">    return data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  // `transformResponse`可以在响应数据被传递给/ catch之前进行更改</span><br><span class="line">  transformResponse: [function (data) &#123;</span><br><span class="line">    // Do whatever you want to transform the data</span><br><span class="line">    return data;</span><br><span class="line">  &#125;],</span><br><span class="line"></span><br><span class="line">  // `headers`是要发送的自定义标题</span><br><span class="line">  // headers: &#123;&apos;Content-Type&apos;: &apos;application/json;charset=UTF-8&apos;&#125;,</span><br><span class="line">  // `params`是与请求一起发送的URL参数</span><br><span class="line">  params: &#123;&#125;,</span><br><span class="line"></span><br><span class="line">  // `paramsSerializer`是一个可选的函数，负责序列化`params`</span><br><span class="line">  // (e.g. https://www.npmjs.com/package/qs, http://api.jquery.com/jquery.param/)</span><br><span class="line">  paramsSerializer: function (params) &#123;</span><br><span class="line">    return Qs.stringify(params, &#123;arrayFormat: &apos;brackets&apos;&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当某个请求需要使用 application/json类型提交时，可以在具体的那个请求上面重写默认的axios配置。如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import fetch from &apos;../utils/http&apos;</span><br><span class="line">export function  login(data) &#123;</span><br><span class="line">  return fetch(&#123;</span><br><span class="line">    url:&apos;/login&apos;,</span><br><span class="line">    method:&apos;post&apos;,</span><br><span class="line">    credentials: &quot;include&quot;,</span><br><span class="line">    data:data,</span><br><span class="line">    transformRequest: [function (data) &#123;</span><br><span class="line">      data=JSON.stringify(data)</span><br><span class="line">      return data;</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>只需要重写请求时的 transformRequest 方法即可。当其他默认配置需要个性化时，则同样做个性化重写即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/ambitionkingman/2018/03/07/java/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wu Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://p4ucv3uvl.bkt.clouddn.com/avatar/godnaruto.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wuwei` Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/07/java/" itemprop="url">java相关</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-07T23:21:32+08:00">
                2018-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><h4 id="HashMap-LinkedHashMap"><a href="#HashMap-LinkedHashMap" class="headerlink" title="HashMap,LinkedHashMap"></a>HashMap,LinkedHashMap</h4><p>Java HashMap,LinkedHashMap<br>如果需要使用的Map中的key无序，选择HashMap；如果要求key有序，则选择TreeMap。<br>但是选择TreeMap就会有性能问题，因为TreeMap的get操作的时间复杂度是O(log(n))的，<br>相比于HashMap的O(1)还是差不少的，LinkedHashMap的出现就是为了平衡这些因素，使得能够以O(1)时间复杂度增加查找元素，又能够保证key的有序性此外，LinkedHashMap提供了两种key的顺序：<br>      ○ 访问顺序（access order）。非常实用，可以使用这种顺序实现LRU（Least Recently Used）缓存<br>      ○ 插入顺序（insertion orde）。同一key的多次插入，并不会影响其顺序</p>
<h5 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h5><ol>
<li><p>HashMap构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public HashMap(int initialCapacity, float loadFactor) &#123;</span><br><span class="line">    if (initialCapacity &lt; 0)</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; + initialCapacity);</span><br><span class="line">    if (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; + loadFactor);</span><br><span class="line">    this.loadFactor = loadFactor;</span><br><span class="line">    threshold = initialCapacity;</span><br><span class="line">    init();   //注意这个模板函数，在LinkHashMap中有使用</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>默认参数</p>
<blockquote>
<p>容量必须为2的指数（默认为16），想想原因？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;</span><br><span class="line"></span><br><span class="line">static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<blockquote>
<p>默认的平衡因子为0.75，这是权衡了时间复杂度与空间复杂度之后的取值<br>//过高的因子可以增加存储空间利用率但是查找的时间就会增加。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static final float DEFAULT_LOAD_FACTOR = 0.75f;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<ol>
<li>重设索引<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">void resize(int newCapacity) &#123;</span><br><span class="line">    Entry[] oldTable = table;</span><br><span class="line">    int oldCapacity = oldTable.length;</span><br><span class="line">    if (oldCapacity == MAXIMUM_CAPACITY) &#123;</span><br><span class="line">        threshold = Integer.MAX_VALUE;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Entry[] newTable = new Entry[newCapacity];</span><br><span class="line">    transfer(newTable, initHashSeedAsNeeded(newCapacity));</span><br><span class="line">    table = newTable;</span><br><span class="line">    threshold = (int)Math.min(newCapacity * loadFactor, MAXIMUM_CAPACITY + 1);</span><br><span class="line">&#125;</span><br><span class="line">void transfer(Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">    int newCapacity = newTable.length;</span><br><span class="line">    for (Entry&lt;K,V&gt; e : table) &#123;</span><br><span class="line">        while(null != e) &#123;</span><br><span class="line">            Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">            if (rehash) &#123;</span><br><span class="line">                e.hash = null == e.key ? 0 : hash(e.key);</span><br><span class="line">            &#125;</span><br><span class="line">            int i = indexFor(e.hash, newCapacity);    //占用哪个槽位</span><br><span class="line">            e.next = newTable[i];</span><br><span class="line">            newTable[i] = e;</span><br><span class="line">            e = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static int indexFor(int h, int length) &#123;</span><br><span class="line">    // assert Integer.bitCount(length) == 1 : &quot;length must be a non-zero power of 2&quot;;</span><br><span class="line">    return h &amp; (length-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h5 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h5><ol>
<li><p>Entry</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    private static class Entry&lt;K,V&gt; extends HashMap.Entry&lt;K,V&gt; &#123;</span><br><span class="line">        // These fields comprise the doubly linked list used for iteration.</span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line"></span><br><span class="line">        Entry(int hash, K key, V value, HashMap.Entry&lt;K,V&gt; next) &#123;</span><br><span class="line">            super(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除</p>
<blockquote>
<p>删除一个节点时，需要把<br>前继节点的后继指针 指向 要删除节点的后继节点<br>后继节点的前继指针 指向 要删除节点的前继节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private void remove() &#123;</span><br><span class="line">    before.after = after;</span><br><span class="line">    after.before = before;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ol>
<p>3.增加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private void addBefore(Entry&lt;K,V&gt; existingEntry) &#123;</span><br><span class="line">    after  = existingEntry;            //当前节点的后继节点 指向 新节点</span><br><span class="line">    before = existingEntry.before;     //</span><br><span class="line">    before.after = this;               //</span><br><span class="line">    after.before = this;               //</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>重写的init</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">void init() &#123;</span><br><span class="line">    header = new Entry&lt;&gt;(-1, null, null, null);</span><br><span class="line">    header.before = header.after = header;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写transfer</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">void transfer(HashMap.Entry[] newTable, boolean rehash) &#123;</span><br><span class="line">    int newCapacity = newTable.length;</span><br><span class="line">    for (Entry&lt;K,V&gt; e = header.after; e != header; e = e.after) &#123;    //把链表里的元素重排序</span><br><span class="line">        if (rehash)</span><br><span class="line">            e.hash = (e.key == null) ? 0 : hash(e.key);</span><br><span class="line">        int index = indexFor(e.hash, newCapacity);</span><br><span class="line">        e.next = newTable[index];</span><br><span class="line">        newTable[index] = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>效率：<br>方法调用：别每次都直接调用方法，尽量将方法赋值，然后调用赋值后的变量，避免重复调用方法。效率问题。<br>Map：使用HashMap的匿名内部类Entry遍历比使用keySet()效率要高很多，使用forEach循环时要注意不要在循环的过程中改变键值对的任何一方的值，否则出现哈希表的值没有随着键值的改变而改变，到时候在删除的时候会出现问题。<br>      此外，entrySet比keySet快些。对于keySet其实是遍历了2次，一次是转为iterator，一次就从hashmap中取出key所对于 的value。而entrySet只是遍历了第一次，他把key和value都放到了entry中，所以就快了。</p>
<ol>
<li>同时遍历key和value时，keySet与entrySet方法的性能差异 取决于key的具体情况，如复杂度（复杂对象）、离散度、冲突率等。换言之，取决于HashMap查找value的开销。entrySet一次性取出所有 key和value的操作是有性能开销的，当这个损失小于HashMap查找value的开销时，entrySet的性能优势就会体现出来。例如上述对比 测试中，当key是最简单的数值字符串时，keySet可能反而会更高效，耗时比entrySet少10%。总体来说还是推荐使用entrySet。因为 当key很简单时，其性能或许会略低于keySet，但却是可控的；而随着key的复杂化，entrySet的优势将会明显体现出来。当然，我们可以根据 实际情况进行选择</li>
<li>只遍历key时，keySet方法更为合适，因为entrySet将无用的value也给取出来了，浪费了性能和空间。在上述测试结果中，keySet比entrySet方法耗时少23%。</li>
<li>只遍历value时，使用vlaues方法是最佳选择，entrySet会略好于keySet方法。</li>
<li>在不同的遍历写法中，推荐使用如下写法，其效率略高一些：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (String key : map.keySet()) &#123;  value = map.get(key); &#125;</span><br><span class="line"></span><br><span class="line">for (Entry&lt;String, String&gt; entry: map.entrySet()) &#123;  key = entry.getKey();  value = entry.getValue(); &#125;</span><br><span class="line"></span><br><span class="line">for (String value : map.values()) &#123; &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/ambitionkingman/2018/03/07/linux/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wu Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://p4ucv3uvl.bkt.clouddn.com/avatar/godnaruto.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wuwei` Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/07/linux/" itemprop="url">Linux 笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-07T23:19:42+08:00">
                2018-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Linux-笔记"><a href="#Linux-笔记" class="headerlink" title="Linux 笔记"></a>Linux 笔记</h3><p>LINUX笔记：<br>最左边的 root 显示的是『目前使用者的账号』， 而 @ 之后接的 linux 则是『主机名称』，至于最右边的 ~ 则指的是 『目前所在的目录』，那么那个 # 则是我们常常讲的『提示字符』啦！<br>Tips: 那个 ~ 符号代表的是『使用者的家目录』的意思，他是个『变量！』这相关的意义我们会在后续的章节依序介绍到。举例来说，root 的家目录在 /root， 所以 ~ 就代表 /root 的意思～而 dmtsai 的家目录在 /home/dmtsai， 所以如果您以 dmtsai 登入时，他看到的 ~ 就会等于 /home/dmtsai 喔！<br>至于提示字符方面，在 Linux 当中，预设 root 的提示字符为 # ，而一般身份使用者的提示字符为 $ 。<br>开始下达指令：<br>其实整个指令下达的方式很简单，您只要记得几个重要的概念就可以了。 举例来说，你可以这样下达指令的：<br>[root@linux ~]# command [-options] parameter1 parameter2 …<br>指令 选项 参数(1) 参数(2)<br>说明：</p>
<ol>
<li>一行指令中第一个输入的绝对是『指令(command)』或『可执行档案』</li>
<li>command 为指令<br>的名称，例如变换路径的指令为 cd 等等；</li>
<li>中括号[]并不存在于实际的指令中，而加入参数设定时，通常为 - 号，例如 -h；<br>有时候完整参数名称会输入 – 符号，例如 –help；</li>
<li>parameter1 parameter2.. 为依附在 option 后面的参数，<br>或者是 command 的参数；</li>
<li>command, -options, parameter1.. 这几个咚咚中间以空格来区分，<br>不论空几格 shell 都视为一格；</li>
<li>按下 [Enter] 按键后，该指令就立即执行。[Enter] 按键为 <cr> 字符，<br>他代表着一行指令的开始启动。</cr></li>
<li>指令太长的时候，可以使用 \ 符号来跳脱 [Enter] 符号，<br>使指令连续到下一行。注意！ \ 后就立刻接特殊字符。<br>其它：<br>a. 在 Linux 系统中，英文大小写字母是不一样的。举例来说， cd 与 CD 并不同。<br>b. 更多的介绍等到 bash 时，再来详述。<br>• 显示日期的指令： date<br>• 显示日历的指令： cal<br>• 简单好用的计算器： bc<br>• [Tab] 按键<br>• [Tab] 接在一串指令的第一个字的后面，则为命令补全；<br>• [Tab] 接在一串指令的第二个字以后时，则为『档案补齐』！<br>[Tab] 按键就是在键盘的大写灯切换按键([Caps Lock])上面的那个按键！ 在各种 Unix-Like 的 Shell 当中，这个 [Tab] 按键算是 Linux 的 Bash shell 最棒的功能之一了！ 他具有『命令补全』与『档案补齐』的功能喔！可以让我们少打很多字，但重点是， 可以避免我们打错指令或文件名称呢！很棒吧！但是 [Tab] 按键在不同的地方输入，会有不一样的结果喔！ 我们举下面的例子来说明。上一小节我们不是提到 cal 这个指令吗？如果我在指令列输入 ca 再按两次 [tab] 按键，会出现什么讯息？<br>[root@linux ~]# ca[tab][tab] &lt;==[tab]按键是紧接在 a 字母后面！<h1 id="上面的-tab-指的是『按下那个tab键』，不是要您输入-ca-…-的意思喔！"><a href="#上面的-tab-指的是『按下那个tab键』，不是要您输入-ca-…-的意思喔！" class="headerlink" title="上面的 [tab] 指的是『按下那个tab键』，不是要您输入 ca[… 的意思喔！"></a>上面的 [tab] 指的是『按下那个tab键』，不是要您输入 ca[… 的意思喔！</h1>cadaver callgrind_control capiinit case<br>cal cancel capinfos cat<br>calibrate_ppa cancel.cups captoinfo catchsegv<br>caller capifax card<br>callgrind capifaxrcvd cardctl<br>callgrind_annotate capiinfo cardmgr<br>发现什么事？所有以 ca 为开头的指令都被显示出来啦！很不错吧！ 那如果你输入 ls -al ~/.bash 两个 [tab] 会出现什么？<br>[root@linux ~]# ls -al ~/.bash[tab][tab]<br>.bash_history .bash_logout .bash_profile .bashrc<br>• [Ctrl]-c 按键<br>中断程序按键<br>• [Ctrl]-d 按键<br>这个组合按键通常代表着： 『键盘输入结束 (End Of File, EOF 或 End Of Input)』的意思！ 另外，他也可以用来取代 exit 的输入呢！<br>Manual Page<br>manual 指令：查看帮助手册<br>一点来看这个 man page 的话， 您会发现几个有趣的东西。 首先，在上个表格的第一行，您可以看到的是：『DATE(1)』， DATE 我们知道是指令的名称， 那么 (1) 代表什么呢？他代表的是『一般使用者可使用的指令』的意思！咦！还有这个用意啊！！呵呵！ 没错～在查询数据的后面的数字是有意义的喔！他可以帮助我们了解或者是直接查询相关的资料。 常见的几个数字的意义是这样的：<br>代号<br>代表内容<br>1<br>使用者可以操作的指令或可执行文件<br>2<br>系统核心可呼叫的函数与工具等<br>3<br>一些常用的函数(function)与函式库(library)<br>4<br>装置档案的说明<br>5<br>设定档或者是某些档案的格式<br>6<br>游戏(games)<br>7<br>惯例与协议等，例如 Linux 标准档案系统、 网络协议、ASCII code 等等的说明内容<br>8<br>系统管理员可用的管理指令<br>9<br>跟 kernel 有关的文件<br>空格键<br>向下翻一页<br>[Page Down]<br>向下翻一页<br>[Page Up]<br>向上翻一页<br>[Home]<br>去到第一页<br>[End]<br>去到最后一页<br>/string<br>向『下』搜寻 string 这个字符串，如果要搜寻 vbird 的话，就输入 /vbird<br>?string<br>向『上』搜寻 string 这个字符串<br>n, N<br>利用 / 或 ? 来搜寻字符串时，可以用 n 来继续下一个搜寻 (不论是 / 或 ?) ，可以利用 N 来进行『反向』搜寻。举例来说，我以 /vbird 搜寻 vbird 字符串， 那么可以 n 继续往下查询，用 N 往上查询。若以 ?vbird 向上查询 vbird 字符串， 那我可以用 n 继续『向上』查询，用 N 反向查询。<br>q<br>结束这次的 man page。<br>LINUX关机的正确方法：<br>• 将数据同步写入硬盘中的指令： sync             –只有root管理员才可以执行。<br>• 惯用的关机指令： shutdown<br>• 重新开机，关机： reboot, halt, poweroff<br>shutdown：<br>-t sec ： -t 后面加秒数，亦即『过几秒后关机』的意思<br>-k ： 不要真的关机，只是发送警告讯息出去！<br>-r ： 在将系统的服务停掉之后就重新开机<br>-h ： 将系统的服务停掉后，立即关机。<br>-n ： 不经过 init 程序，直接以 shutdown 的功能来关机<br>-f ： 关机并开机之后，强制略过 fsck 的磁盘检查<br>-F ： 系统重新开机之后，强制进行 fsck 的磁盘检查<br>-c ： 取消已经在进行的 shutdown 指令内容。<br>多终端登录：<br>请问如果我以文字模式登入 Linux 主机时，我有几个终端机接口可以使用？如何切换各个不同的终端机接口？<br>共有六个， tty1 ~ tty6 ，切换的方式为 Crtl + Alt + [F1]~[F6]，其中， [F7] 为图形接口的使用。</li>
</ol>
<p>Linux 档案属性：<br>嗯！既然要让你了解 Linux 的档案属性，那么有个重要的也是常用的指令就必须要先跟你说啰！那一个？！就是『 ls 』这一个 list 档案的指令啰！在你以 root 的身份登入 Linux 之后，下达『ls -al 』看看，会看到底下的几个咚咚：<br>[root@linux ~]# ls -al<br>total 248<br>drwxr-x— 9 root root 4096 Jul 11 14:58 .<br>drwxr-xr-x 24 root root 4096 Jul 9 17:25 ..<br>-rw——- 1 root root 1491 Jun 25 08:53 anaconda-ks.cfg<br>-rw——- 1 root root 13823 Jul 10 23:12 .bash_history<br>-rw-r–r– 1 root root 24 Dec 4 2004 .bash_logout<br>-rw-r–r– 1 root root 191 Dec 4 2004 .bash_profile<br>-rw-r–r– 1 root root 395 Jul 4 11:45 .bashrc<br>-rw-r–r– 1 root root 100 Dec 4 2004 .cshrc<br>drwx—— 3 root root 4096 Jun 25 08:35 .ssh<br>-rw-r–r– 1 root root 68495 Jun 25 08:53 install.log<br>-rw-r–r– 1 root root 5976 Jun 25 08:53 install.log.syslog<br>[ 1 ][ 2 ][ 3 ][ 4 ][ 5 ][ 6 ][ 7 ]<br>[ 属性 ][连结][拥有者][群组][档案容量][ 修改日期 ][ 檔名 ]<br>ls 是『list』的意思，与在早期的 DOS 年代的指令 dir 类似功能。 而参数『-al』则表示列出所有的档案 ( 包含隐藏档，就是档名前面第一个字符为 . 的那种档案 ) 。如上所示，在你第一次以 root 身份登入 Linux 时，如果你输入指令后，应该有上列的几个东西， 先解释一下上面七个字段个别的意思：</p>
<ol>
<li>第一栏代表这个档案的属性： 这个地方最需要注意了！仔细看的话，你应该可以发现这一栏其实共有十个属性：</li>
</ol>
<p>o 第一个属性代表这个档案是『目录、档案或连结文件等等』：<br>􀂃 当为[ d ]则是目录，例如上表的第 11 行；<br>􀂃 当为[ - ]则是档案，例如上表的第 5 行；<br>􀂃 若是[ l ]则表示为连结档(link file)；<br>􀂃 若是[ b ]则表示为装置文件里面的可供储存的接口设备；<br>􀂃 若是[ c ]则表示为装置文件里面的串行端口设备，例如键盘、鼠标。<br>o 接下来的属性中，三个为一组，且均为『rwx』 的三个参数的组合。其中，[ r ]代表可读(read)、[ w ]代表可写(write)、[ x ]代表可执行(excute)：<br>􀂃 第一组为『拥有人的权限』，以第 5 行为例，该档案的拥有人可以读写，但不可执行；<br>􀂃 第二组为『同群组的权限』；<br>􀂃 第三组为『其它非本群组的权限』。<br>范例：若有一个档案的属性为『-rwxr-xr–』，简单的可由下面说明之：<br>[-][rwx][r-x][r–]<br>1 234 567 890<br>1 为：代表这个文件名为目录或档案（上面为档案）<br>234为：拥有人的权限（上面为可读、可写、可执行）<br>567为：同群组使用者权限（上面为可读可执行）<br>890为：其它使用者权限（上面为仅可读）<br>上面的属性情况代表一个档案、这个档案的拥有人可读可写可执行、但同群组的人仅可读与执行， 非同群组的使用者仅可读的意思！<br>2.第二栏表示为连接占用的节点(i-node):这个跟连结档(link file)比较有关系。<br>3.第三栏表示这个档案（或目录）的『拥有人』。<br>4.第四栏表示拥有人的群组。<br>5.第五栏为这个档案的容量大小。<br>6.第六栏为该档案的最近修改日期。<br>7.第七栏为这个档案的档名，如果档名前多一个【.】，则代表改文档为隐藏文档。<br>如果您想要开放某个目录让一些人进来的话， 请记得将该目录的 x 属性给开放呦！<br>• chgrp ：改变档案所属群组<br>• chown ：改变档案所属人<br>• chmod ：改变档案的属性、 SUID</p>
<p>• chgrp ：改变档案所属群组<br>改变一个档案的群组真是很简<br>嘛！对啦！这样就很好记了吧！ ^_^。不过，请记得， 要改变成为的群组名称必须要在 /etc/group 里面存在的名称才行，否则就会显示错误！<br>[root@linux ~]# chmod u=rwx,go=rx .bashrc</p>
<h1 id="注意喔！那个-u-rwx-go-rx-是连在一起的，中间没有空格符。"><a href="#注意喔！那个-u-rwx-go-rx-是连在一起的，中间没有空格符。" class="headerlink" title="注意喔！那个 u=rwx,go=rx 是连在一起的，中间没有空格符。"></a>注意喔！那个 u=rwx,go=rx 是连在一起的，中间没有空格符。</h1><p>可以用数字代表各个属性：<br>r:4<br>w:2<br>x:1</p>
<p>Linux的档案种类主要有以下几种：<br>• 正规档案 (regular file )： 就是一般我们在进行存取的类型的档案，在由 ls –al 所显示出来的属性方面，第一个属性为 [ - ]，例如 [-rwxrwxrwx ]。另外，依照档案的内容，又大略可以分为：<br>o 纯文字文件(ASCII)：这是 Unix 系统中最多的一种档案类型啰，称为纯文字文件是因为内容为我们人类可以直接读到的数据， 例如数字、字母等等。几乎只要我们可以用来做为设定的档案都属于这一种档案类型。 举例来说，您可以下达『 cat ~/.bashrc 』就可以看到该档案的内容。 (cat 是将一个档案内容读出来的指令)<br>o 二进制文件(binary)：还记得我们在『 Linux 是什么 』那一章里面的 GNU 发展史中提过， 我们的系统其实仅认识且可以执行二进制档案 (binary file) 吧？没错～ 您的 Linux 当中的可执行档 (scripts, 文字型批次文件不算) 就是这种格式的啦～ 举例来说，刚刚下达的指令 cat 就是一个 binary file 。<br>o 数据格式文件(data)： 有些程序在运作的过程当中会读取某些特定格式的档案，那些特定格式的档案可以被称为数据文件 (data file)。举例来说，我们的 Linux 在使用者登入时，都会将登录的数据记录在 /var/log/wtmp 那个档案内，该档案是一个 data file ，他能够透过 last 这个指令读出来！ 但是使用 cat 时，会读出乱码～因为他是属于一种特殊格式的档案。瞭乎？<br>• 目录 (directory)：就是目录啰～第一个属性为 [ d ]，例如 [drwxrwxrwx]。<br>• 连结档 (link)：就是类似 Windows 底下的快捷方式啦！第一个属性为 [ l ]， 例如 [lrwxrwxrwx] ；<br>• 设备与装置文件 (device)：与系统周边及储存等相关的一些档案， 通常都集中在 /dev 这个目录之下！通常又分为两种：<br>o 区块 (block) 设备档 ：就是一些储存数据， 以提供系统存取的接口设备，简单的说就是硬盘啦！例如你的一号硬盘的代码是 /dev/hda1 等等的档案啦！第一个属性为 [ b ]；<br>o 字符 (character) 设备档 ：亦即是一些串行端口的接口设备， 例如键盘、鼠标等等！第一个属性为 [ c ]。<br>•资料接口文件 (sockets)：既然被称为数据接口文件， 想当然尔，这种类型的档案通常被用在网络上的数据承接了。我们可以启动一个程序来监听客户端的要求， 而客户端就可以透过这个 socket 来进行数据的沟通了。第一个属性为 [ s ]， 最常在 /var/run 这个目录中看到这种档案类型了。<br>• 数据输送文件 (FIFO, pipe)： FIFO 也是一种特殊的档案类型，他主要的目的在解决多个程序同时存取一个档案所造成的错误问题。 FIFO 是 first-in-first-out 的缩写。第一个属性为 [p] 。<br>有数种常用的附档名：<br>• <em>.sh ： 批次檔 ( scripts )，因为批次档为使用 shell 写成的，所以附档名就编成 .sh 啰；<br>• </em>Z, <em>.tar, </em>.tar.gz, <em>.zip, </em>.tgz： 经过打包的压缩档。这是因为压缩软件分别为 gunzip, tar 等等的，由于不同的压缩软件，而取其相关的附档名啰！<br>• <em>.html, </em>.php：网页相关档案，分别代表 HTML 语法与 PHP 语法的网页档案啰！ .html 的档案可使用网页浏览器来直接开启，至于 .php 的档案， 则可以透过 client 端的浏览器来 server 端浏览，以得到运算后的网页结果呢！<br>Linux 在文字接口下的一些指令操作关系，一般来说，您在设定 Linux 底下的文件名称时， 最好可以避免一些特殊字符比较好！例如底下这些：</p>
<ul>
<li>? &gt; &lt; ; &amp; ! [ ] | \ ‘ “ ` ( ) { }<br>FHS：<br>这个 FHS ( <a href="http://www.pathname.com/fhs/" target="_blank" rel="noopener">http://www.pathname.com/fhs/</a> ) 事实上仅是规范出在根目录 ( / ) 底下各个主要的目录应该是要放置什么样的档案而已。 FHS 定义出两层规范出来，第一层是 / 底下的各个目录应该要放置什么样内容的档案数据，例如 /etc 应该要放置设定档， /bin 与 /sbin 则应该要放置可执行档等等。第二层则是针对 /usr 及 /var 这两个目录的次目录来定义的。 例如 /var/log 放置系统登录文件、 /usr/share 放置共享数据等等。<br>目录树：<br>Linux 底下，所有的档案与目录都是由根目录 / 开始的！那是所有目录与档案的源头～ 然后再一个一个的分支下来，有点像是树枝状啊～因此，我们也称这种目录配置方式为：『目录树 (directory tree)』<br>文档名的书写：<br>根据档名写法的不同，也可将所谓的路径 (path) 定义为绝对路径 (absolute) 与相对路径 (relative)。 绝对路径为：由根目录 (/) 开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；相对路径为相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 ../../home/dmtsai/ 等等。反正开头不是 / 就属于相对路径的写法， 而您必须要了解，相对路径是以『您当前所在路径的相对位置』来表示的。举例来说，您目前在 /home 这个目录下， 如果想要进入 /var/log 这个目录时，可以怎么写呢？<br>• cd /var/log (absolute)<br>• cd ../var/log (relative)<br>因为您在 /home 底下，所以要回到上一层 (../) 之后，才能继续往 /var 来移动的！ 特别注意这两个特殊的目录：<br>• . ：代表当前的目录，也可以使用 ./ 来表示；<br>• .. ：代表上一层目录，也可以 ../ 来代表。<br>这个 . 与 .. 目录概念是很重要的，您常常会看到 cd .. 或 ./command 之类的指令下达方式， 就是代表上一层与目前所在目录的工作状态喔！很重要的吶！此外，针对『档名』与『完整档名 (由 / 开始写起的文件名)』 的字符限制大小为：<br>• 单一档案或目录的最大容许文件名为 255 个字符；<br>• 包含完整路径名称及目录 (/) 之完整档名为 4096 个字符。</li>
</ul>
<p>如果以『账号』的角度来看，所谓的 root 指的是『系统管理员！』的身份， 如果以『目录』的角度来看，所谓的 root 意即指的是根目录。<br>Linux目录结构：</p>
<p>请注意，每个目录都是依附在 / 这个根目录底下的，所以我们在安装的时候一定要有一个 / 对应的 partition 才能安装的原因即在于此！这也就是我们俗称的『树状目录』啰！而根据 FHS 定义出来的每个目录内应该放置的档案内容为：<br>目录<br>应放置档案内容<br>/<br>根目录 root (/)，一般建议在根目录底下只接目录，不要直接有档案在 / 底下。 根目录是开机的时候系统第一个挂载的 partition ，所以，所有开机过程会用到的档案， 应该都要放置在这个 partition 当中。举例来说，/etc, /bin, /dev, /lib, /sbin 这五个次目录都应该要与根目录连在一起，不可独立成为某个 partition 呢！<br>/bin, /usr/bin, /usr/local/bin<br>除了 /bin 之外， /usr/local/bin, /usr/bin 也是放置『使用者可执行的 binary file 的目录』喔！举例来说，ls, mv, rm, mkdir, rmdir, gzip, tar, cat, cp, mount 等等重要指令都放在这个目录当中。<br>/boot<br>这个目录主要的目的是放置 Linux 系统开机会用到的档案。 开机会用到什么呢？没错～就是 Linux 的核心档案。这个目录底下文件名为 vmlinuz 的就是 Linux 的 Kernel 啦！粉重要的东西！ 而如果你的开机管理程序 (loader) 选择 grub 的话，那么这个目录内还有 /boot/grub 这个次目录呦！<br>/dev<br>在 Linux 系统上，任何装置与接口设备都是以档案的型态存在于这个目录当中的。 您只要透过存取这个目录底下的某个档案，就等于存取某个装置啰～ 主要又分为接口设备 (character device)，例如键盘、鼠标等；以及储存设备 (block device)， 例如硬盘、光盘等等。在此目录下的档案会多出两个属性，分别是 major device number ， 与 minor device number 。我们的系统核心就是透过这两个 number 来判断装置的呢！ 比要重要的档案有 /dev/null, /dev/tty[1-6], /dev/ttyS<em>, /dev/lp</em>, /dev/hd<em>, /dev/sd</em> 等等<br>/etc<br>系统主要的设定文件几乎都放置在这个目录内，例如人员的账号密码文件、 各种服务的启始档等等。一般来说，这个目录下的各档案属性是可以让一般使用者查阅的， 但是只有 root 有权力修改。并且在此目录下的档案几乎都是 ASCII 的纯文本文件哩。 不过， FHS 建议不要放置可执行文件在这个目录中喔。比较重要的档案有： /etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11, /etc/fstab, /etc/sysconfig/ 等等。另外，其下重要的目录有：<br>• /etc/init.d/：所有服务的预设启动 script 都是放在这里的，例如要启动或者关闭 iptables 的话： /etc/init.d/iptables start /etc/init.d/iptables stop<br>• /etc/xinetd.d/：这就是所谓的 super daemon 管理的各项服务的设定文件目录。<br>• /etc/X11：与 X Window 有关的各种设定档都在这里，尤其是 xorg.conf 或 XF86Config 这两个 X Server 的设定档。<br>/home<br>这是系统预设的使用者家目录 (home directory)。在你新增一个一般使用者账号时， 预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号喔： ~：代表目前这个使用者的家目录，而 ~dmtsai ：则代表 dmtsai 的家目录！<br>/lib, /usr/lib, /usr/local/lib<br>系统会使用到的函式库放置的目录。 程序在运作的过程中，可能会呼叫一些额外的功能参数，那需要函式库的协助！ 这些函式库就放在此处。比较重要的是 /lib/modules 这个目录内会摆放 kernel 的相关模块喔！<br>/lost+found<br>系统不正常产生错误时，会将一些遗失的片段放置于此目录下， 通常这个目录会自动出现在某个 partition 最顶层的目录下。例如你加装一棵硬盘于 /disk 中， 那在这个目录下就会自动产生一个这样的目录 /disk/lost+found<br>/mnt /media<br>这是软盘与光盘预设挂载点的地方；通常软盘挂在 /mnt/floppy 下，而光盘挂在 /mnt/cdrom 下，不过也不一定啦！只要你高兴，随便找一个地方来挂载也可以呀！另外，目前也规划出另一个 /media 的目录呢！与 /mnt 有点类似啦～<br>/opt<br>这是给主机额外安装软件所摆放的目录。举例来说， FC4 使用的是 Fedora 社群开发的软件， 如果您今天想要自行安装新的 KDE 桌面软件的话，可以将该软件安装在这个目录下的意思。 不过，以前的 Linux 系统中，我们还是习惯放置在 /usr/local 目录下呢！<br>/proc<br>这个目录本身是一个『虚拟档案系统』喔！他放置的数据都是在内存当中， 例如系统核心、形成信息、接口设备的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！比较重要的档案例如：/proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/<em> 等等。<br>/root<br>系统管理员 (root) 的家目录。之所以放在这里， 是因为我们提过，系统第一个开机就被挂载的 partition 为 / ， 而我们希望 /root 能够与 / 放在同一块 partition 上面之故。<br>/sbin, /usr/sbin, /usr/local/sbin<br>放置一些系统管理员才会动用到的执行指令，例如： fdisk, mke2fs, fsck, mkswap, mount 等等。与 /bin 不太一样的地方，这几个目录是给 root 等系统管理用的。但是本目录下的执行文件还是可以让一般使用者用来『察看』而不能设定喔！<br>/srv<br>一些服务启动之后，这些服务所需要取用的数据目录。举例来说，WWW 服务器需要的网页资料就可以放置在 /srv/www 里面。<br>/tmp<br>这是让一般使用者或者是正在执行的程序暂时放置档案的地方。 这个目录是任何人都能够存取的，所以您需要定期的清理一下。当然，重要数据不可放置在此目录啊！<br>/usr<br>由 FHS 规范的第二层内容，在 /usr 此目录下，包含系统的主要程序、 图形接口所需要的档案、额外的函式库、本机端所自行安装的软件，以及共享的目录与文件等等， 都可以在这个目录当中发现。事实上，他有点像是 Windows 操作系统当中的『Program files』与 『WinNT』这两个目录的结合！在此目录下的重要次目录有：<br>• /usr/bin, /usr/sbin：一般身份使用者与系统管理员可执行的档案放置目录；<br>• /usr/include：c/c++等程序语言的档头 (header) 与包含档(include)放置处， 当我们以 tarball 方式 (</em>.tar.gz 的方式安装软件) 安装某些数据时，会使用到里头的许多包含档喔！；<br>• /usr/lib：各应用软件的函式库档案放置目录；<br>• /usr/local：本机端自行安装的软件预设放置的目录。目前也适用于 /opt 目录。 在你安装完了 Linux 之后，基本上所有的配备你都有了，但是软件总是可以升级的， 例如你要升级你的 proxy 服务，则通常软件预设的安装地方就是在 /usr/local (local 是『当地』的意思)，同时，安装完毕之后所得到的执行文件，为了与系统原先的执行文件有分别， 因此升<br>级后的执行档通常摆在 /usr/local/bin 这个地方。给个建议啦， 通常鸟哥都会将后来才安装上去的软件放置在这里，因为便于管理呦；<br>• /usr/share：共享文件放置的目录，例如底下两个目录：<br>• /usr/share/doc：放置一些系统说明文件的地方，例如你安装了 grub 了，那么在该目录底下找一找，就可以查到 lilo 的说明文件了！很是便利！<br>• /usr/share/man：manpage 的文件档案目录；那是什么？呵呵！ 就是你使用 man 的时候，会去查询的路径呀！例如你使用 man ls 这个指令时，就会查出 /usr/share/man/man1/ls.1.gz 这个说明档的内容啰！<br>• /usr/src：Linux 系统相关的程序代码放置目录，例如/usr/src/linux 为核心原始码！<br>• /usr/X11R6：系统内的 X Window System 所需的执行档几乎都放在这！<br>/var<br>这个目录也很重要，也是 FHS 规范的第二层目录内容。他主要放置的是针对系统执行过程中， 常态性变动的档案放置的目录。举例来说，例如快取档案 (cache) 或者是随时变更的登录档 (log file) 都是放在这个目录中的。此外，某些软件执行过程中会写入的数据库档案， 例如 MySQL 数据库，也都写入在这个目录中！很重要吧！他底下的重要目录有：<br>• /var/cache：程序档案在运作过程当中的一些暂存盘；<br>• /var/lib：程序本身执行的过程中，需要使用到的数据文件放置的目录， 举例来说， locate 这个数据库与 MySQL 及 rpm 等数据库系统，都写在这个目录内。<br>• /var/log：登录文件放置的目录。很重要啊！例如 /var/log/messages 就是总管所有登录档的一个档案！<br>• /var/lock：某些装置具有一次性写入的特性，例如 tab (磁带机)， 此时，为了担心被其它人干扰而破坏正在运作的动作，因此，会将该装置 lock (锁住)起来， 以确定该装置只能被单一个程序所使用啊！<br>• /var/run：某些程序或者是服务启动后，会将他们的 PID 放置在这个目录下喔！<br>• /var/spool：是一些队列数据存放的地方。举例来说，主机收到电子邮件后， 就会放置到 /var/spool/mail 当中，若信件暂时发不出去，就会放置到 /var/spool/mqueue 目录下， 使用者工作排程 (cron) 则是放置在 /var/spool/cron 当中！<br>磁盘分布：<br>你或许可以将你的系统做成这样的 partition 分布：<br>/<br>/boot<br>/usr<br>/home<br>/var<br>这是比较常见的磁盘分布情况，其中：<br>• / 根目录可以分配约 1 GB 以内；<br>• /boot 大概在 50 MB 就可以了，因为开机档案并不大；<br>• /var 就至少需要 1GB 以上，因为你的 mail 、 proxy 预设的储存区都在这个目录中，除非你要将一些设定改变！<br>• /home 与 /usr 通常是最大的，因为你所安装的数据都是在 /usr/ 当中，而用户数据则放置在 /home 当中，因此通常大家都会建议你将所剩下的磁盘空间平均分配给这两个目录说！ 不过也不一定啦！ /usr 大概给个 10G 就很多了～其它的可以都给 /home ，也可以保留一些剩余空间来作为以后的安装与设定用啊！</p>
<p>硬盘挂载：IDE的英文全称为“Integrated Drive Electronics”，即“电子集成驱动器”<br>在我们添加硬盘前，首先要了解linux系统下对硬盘和分区的命名方法。在Linux下对IDE的设备是以hd命名的，第一个ide设备是hda，第二个是hdb。依此类推 我们一般主板上有两个IDE接口，一共可以安装四个IDE设备。主IDE上的两个设备分别对应hda和hdb，第二个IDE口上的两个设备对应hdc和hdd。 一般我们的硬盘安装在主IDE的主接口上，所以是hda，光驱一般安装在第二个IDE的主接口上，所以是hdc(应为hdb是用来命名主IDE上的从接口)，SCSI接口设备是用sd命名的，第一个设备是sda，第二个是sdb。依此类推 分区是用设备名称加数字命名的。例如hda1代表hda这个硬盘设备上的第一个分区。每个硬盘可以最多有四个主分区，作用是1-4命名硬盘的主分区。逻辑分区是从5开始的，每多一个分区，数字加以就可以。 比如我们一般的系统都有一个主分区用来引导系统，这个分区对应我们常说的C区，在linux下命名是hda1。后面我们分三个逻辑分区对应常说的D、E、F，在linux下命名是hda5、hda6、hda7 给硬盘分区 在slackware下有两个分区软件fdisk和cfdisk，例如我们已经有一个硬盘了，现在添加另一个硬盘到系统，那么我们根据命名规则知道这个新添加的硬盘应该是hdb。我们用下面命令给硬盘分区<br>fdisk /dev/hdb<br>你也可以用cfdisk来分区，命令如下：<br>cfdisk /dev/hdb<br>格式化硬盘 格式化成ext3格式<br>mkfs.ext3 /dev/hdb1<br>格式化成reiserfs的格式<br>mkfs.reiserfs /dev/hdb1<br>让硬盘启动自动挂载 例如挂载/dev/hdb1分区到/mnt/hd目录下 用vi编辑/etc/fstab文件，加入如下内容<br>/dev/dhb1 /mnt/hd reiserfs defaults 1 1<br>以前初识Linux时，对Linux系统安装时分区的选择，一点都不了解，导致几次没法进行下一步安装，因此就静下心来，专门拿出时间研究了研究这方面的知识；<br>以下内容就是以前通过研究Linux安装过程中分区的知识总结出来的一些知识；贴上来，做个备份，也希望对Linux初学者有一些帮助。<br>正文：<br>一般来说，在linux系统中都有最少两个挂载点，分别是/ (根目录)及 swap（交换分区），其中，/ 是必须的；<br>详细内容见下文：<br>建议挂载的几大目录：<br>/——-根目录，唯一必须挂载的目录。不要有任何的犹豫，选一个分区，挂载它！（在绝大多数情况下  有2G的容量应该是够用了。当然了，很多东西都是多多益善的）<br>swap—-交换分区，可能不是必须的，不过按照传统，并且照顾到您的安全感，还是挂载它吧。它的容量  只要约等于您的物理内存就可以了，如果超过了您物理内存两倍的容量，那绝对是一种浪费。<br>/home—这是您的家目录，通常您自己创建的文件，都保存在这里，您最好给它分配一个分区<br>/usr—-应用程序目录。大部分的软件都安装在这里，如果您计划安装许多软件，建议也给它分配一个分区<br>/var—-如果您要作一些服务器方面的应用，可以考虑给它分配一个较大的分区<br>/boot—如果您的硬盘不支持LBA模式（不太可能），您最好挂载它，如果挂载，将它挂载在硬盘的第一个  分区，应该比较稳妥。一般来说，挂载的分区只要100M大小就足够了</p>
<p>是否要将这几个挂载点独立分割出来则视你的规划需求而定。可参考以下建议：<br>1.初次接触的新手或硬盘空间有限Desktop的安装建议：<br>   挂载点        装置                      说明<br>     /           /dev/hda1        可用空间-swap大小后的所有空间<br>   swap       /dev/hda2         大约内存大小 建议至少512MB<br>2.高级用户Desktop的安装建议：<br>       挂载点        装置                      说明<br>　 　/               /dev/hda1                10~15G足矣<br> 　　/home       /dev/hda2              最大的剩余空间<br>　 　swap         /dev/hda5         大约内存大小(建议至少512MB)<br>或者<br>       /               /dev/hda1                10~15G足矣<br>      /home       /dev/hda2              最大的剩余空间<br>      /boot        /dev/hda3                 100MB即可<br>      swap         /dev/hda5         大约内存大小(建议至少512MB)<br>3.高级Server用户的安装建议：<br>   挂载点           装置                      说明<br>     /               /dev/hda1               10~15G足矣<br>    /home       /dev/hda2              最大的剩余空间<br>    /boot         /dev/hda3                100MB即可<br>    swap         /dev/hda5        大约内存大小(建议至少512MB)<br>    /var          /dev/hda6      视服务器功能决定大小，至少需要1GB以上<br>或者<br>    /                 /dev/hda1               10~15G足矣<br>   /home         /dev/hda2              最大的剩余空间的一半<br>   /boot          /dev/hda3                100MB即可<br>   swap           /dev/hda5        大约内存大小(建议至少512MB)<br>   /var            /dev/hda6      视服务器功能决定大小，至少需要1GB以上<br>   /usr            /dev/hda7              最大的剩余空间的一半<br>grep命令：<br>Linux系统中grep命令是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式版本，它的使用权限是所有用户。<br>2.格式<br>grep [options]<br>3.主要参数<br>[options]主要参数：<br>－c：只输出匹配行的计数。<br>－I：不区分大 小写(只适用于单字符)。<br>－h：查询多文件时不显示文件名。<br>－l：查询多文件时只输出包含匹配字符的文件名。<br>－n：显示匹配行及 行号。<br>－s：不显示不存在或无匹配文本的错误信息。<br>－v：显示不包含匹配文本的所有行。<br>pattern正则表达式主要参数：<br>\： 忽略正则表达式中特殊字符的原有含义。<br>^：匹配正则表达式的开始行。<br>$: 匹配正则表达式的结束行。<br>\&lt;：从匹配正则表达 式的行开始。<br>>：到匹配正则表达式的行结束。<br>[ ]：单个字符，如[A]即A符合要求 。<br>[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。<br>。：所有的单个字符。</p>
<ul>
<li>：有字符，长度可以为0。<br>• cd：变换目录 change directory<br>• pwd：显示目前的目录 print working directory<br>• mkdir：建立一个新的目录 make directory<br>• rmdir：删除一个空的目录 remove directory</li>
</ul>
<p>复制、移动与删除： cp, rm, mv<br>cp不允许相对路径。靠<br>cp：路径+文件，文件，路径。日<br>linux命令ls会显示出文件的颜色, 系统约定的默认颜色含义如下:<br>白色：表示普通文件<br>蓝色：表示目录<br>绿色：表示可执行文件<br>红色：表示压缩文件<br>浅蓝色：链接文件<br>红色闪烁：表示链接的文件有问题<br>黄色：表示设备文件<br>灰色：表示其他文件<br>取得路径的文件名称与目录名称：basename dirname<br>档案内容查阅：<br>读取文本：cat (concatenate) tac more less head tail。<br>读取文件：od<br>查找文件：locate whereis （从系统数据库中读取数据，可能未更新的数据查找不到）find（从硬盘读取。准确但是速度较慢。）<br>档案预设权限：umask umask -S<br>一种可以直接输入 umask ，就可以看到数字型态的权限设定分数， 一种则是加入 -S (Symbolic) 这个参数，就会以符号类型的方式来显示出权限了！ 奇怪的是，怎么 umask 会有四组数字啊？不是只有三组吗？是没错啦～ 第一组是特殊权限用的.<br>例题四：假设您的 umask 为 003 ，请问该 umask 情况下，建立的档案与目录权限为？ 答：<br>umask 为 003 ，所以拿掉的属性为 ——–wx，因此： 档案： (-rw-rw-rw-) - (——–wx) = -rw-rw-r– 目录： (drwxrwxrwx) - (——–wx) = drwxrwxr–<br>档案隐藏属性：<br>• chattr (设定档案隐藏属性)<br>[root@linux ~]# chattr [+-=][ASacdistu] 档案或目录名称<br>参数：</p>
<ul>
<li>：增加某一个特殊参数，其它原本存在参数则不动。</li>
</ul>
<ul>
<li>：移除某一个特殊参数，其它原本存在参数则不动。<br>= ：设定一定，且仅有后面接的参数<br>A ：当设定了 A 这个属性时，这个档案(或目录)的存取时间 atime (access)<br>将不可被修改，可避免例如手提式计算机容易有磁盘 I/O 错误的情况发生！<br>S ：这个功能有点类似 sync 的功能！就是会将数据同步写入磁盘当中！<br>可以有效的避免数据流失！<br>a ：当设定 a 之后，这个档案将只能增加数据，而不能删除，只有 root<br>才能设定这个属性。<br>c ：这个属性设定之后，将会自动的将此档案『压缩』，在读取的时候将会自动解压缩，<br>但是在储存的时候，将会先进行压缩后再储存(看来对于大档案似乎蛮有用的！)<br>d ：当dump(备份)程序被执行的时候，设定 d 属性将可使该档案(或目录)不具有dump功能<br>i ：这个 i 可就很厉害了！他可以让一个档案『不能被删除、改名、设定连结也无法写入<br>或新增资料！』对于系统安全性有相当大的帮助！<br>j ：当使用 ext3 这个档案系统格式时，设定 j 属性将会使档案在写入时先记录在<br>journal 中！但是当 filesystem 设定参数为 data=journalled 时，由于已经设定了<br>日志了，所以这个属性无效！<br>s ：当档案设定了 s 参数时，他将会被完全的移除出这个硬盘空间。<br>u ：与 s 相反的，当使用 u 来设定档案时，则数据内容其实还存在磁盘中，<br>可以使用来 undeletion.<br>注意：这个属性设定上面，比较常见的是 a 与 i 的设定值，而且很多设定值必须要身为<br>root 才能够设定的喔！<br>范例：<br>[root@linux ~]# cd /tmp<br>[root@linux tmp]# touch attrtest<br>[root@linux tmp]# chattr +i attrtest<br>[root@linux tmp]# rm attrtest<br>rm: remove write-protected regular empty file <code>attrtest&#39;? y
rm: cannot remove</code>attrtest’: Operation not permitted<h1 id="看到了吗？呼呼！连-root-也没有办法将这个档案删除呢！赶紧解除设定！"><a href="#看到了吗？呼呼！连-root-也没有办法将这个档案删除呢！赶紧解除设定！" class="headerlink" title="看到了吗？呼呼！连 root 也没有办法将这个档案删除呢！赶紧解除设定！"></a>看到了吗？呼呼！连 root 也没有办法将这个档案删除呢！赶紧解除设定！</h1>[root@linux tmp]# chattr -i attrtest<br>• lsattr (显示档案隐藏属性)<br>[root@linux ~]# lsattr [-aR] 档案或目录<br>参数：<br>-a ：将隐藏文件的属性也秀出来；<br>-R ：连同子目录的数据也一并列出来！<br>范例：<br>[root@linux tmp]# chattr +aij attrtest<br>[root@linux tmp]# lsattr<br>—-ia—j— ./attrtest<br>档案特殊权限： SUID/SGID/Sticky Bit</li>
</ul>
<p>第二章<br>Linux 系统常见的压缩指令： 2.1 compress 2.2 gzip, zcat 2.3 bzip2, bzcat 2.4 tar 2.5 dd 2.6 cpio<br>gzip, zcat：[root@linux ~]# gzip [-cdt#] 檔名<br>[root@linux ~]# zcat 檔名.gz<br>参数：<br>-c ：将压缩的数据输出到屏幕上，可透过数据流重导向来处理；<br>-d ：解压缩的参数；<br>-t ：可以用来检验一个压缩档的一致性～看看档案有无错误；<br>-# ：压缩等级，-1 最快，但是压缩比最差、-9 最慢，但是压缩比最好！预设是 -6 ～<br>范例：<br>范例一：将 /etc/man.config 复制到 /tmp ，并且以 gzip 压缩<br>[root@linux ~]# cd /tmp<br>[root@linux tmp]# cp /etc/man.config .<br>[root@linux tmp]# gzip man.config</p>
<h1 id="此时-man-config-会变成-man-config-gz-！"><a href="#此时-man-config-会变成-man-config-gz-！" class="headerlink" title="此时 man.config 会变成 man.config.gz ！"></a>此时 man.config 会变成 man.config.gz ！</h1><p>范例二：将范例一的档案内容读出来！<br>[root@linux tmp]# zcat man.config.gz</p>
<h1 id="此时屏幕上会显示-man-config-gz-解压缩之后的档案内容！！"><a href="#此时屏幕上会显示-man-config-gz-解压缩之后的档案内容！！" class="headerlink" title="此时屏幕上会显示 man.config.gz 解压缩之后的档案内容！！"></a>此时屏幕上会显示 man.config.gz 解压缩之后的档案内容！！</h1><p>范例三：将范例一的档案解压缩<br>[root@linux tmp]# gzip -d man.config.gz<br>范例四：将范例三解开的 man.config 用最佳的压缩比压缩，并保留原本的档案<br>[root@linux tmp]# gzip -9 -c man.config &gt; man.config.gz<br>gzip 是用来压缩与解压缩附档名为 <em>.gz 的指令！所以看到 </em>.gz 的档案时，就应该要知道他是经由 gzip 这个程序压缩的呦！另外， gzip 也提供 压缩比的服务！ -1 是最差的压缩比，但是压缩速度最快，而 -9<br>虽然可以达到较佳的压缩比 (经过压缩之后，档案比较小一些！) ，但是却会损失一些速度！预设是 -6 这个数值！ gzip 也是相当常使用的一个压缩指令呢！ 至于 zcat 则是用来读取压缩文件数据内容的指令！假如我们刚刚压缩的档案是一个文字文件， 那么你还记得如何读取文字文件吗？！没错！就是使用 cat ，那么读取压缩档呢？呵呵！就是使用 zcat 啰！由于 gzip 这个压缩指令主要想要用来取代 compress 的，所以 compress 的压缩档案也可以使用 gzip 来解开喔！同时， zcat 这个指令可以同时读取 compress 与 gzip 的压缩档呦！<br>bzip2, bzcat：<br>[root@linux ~]# bzip2 [-cdz] 檔名<br>[root@linux ~]# bzcat 檔名.bz2<br>参数：<br>-c ：将压缩的过程产生的数据输出到屏幕上！<br>-d ：解压缩的参数<br>-z ：压缩的参数<br>-# ：与 gzip 同样的，都是在计算压缩比的参数， -9 最佳， -1 最快！<br>范例：<br>范例一：将刚刚的 /tmp/man.config 以 bzip2 压缩<br>[root@linux tmp]# bzip2 -z man.config</p>
<h1 id="此时-man-config-会变成-man-config-bz2-！"><a href="#此时-man-config-会变成-man-config-bz2-！" class="headerlink" title="此时 man.config 会变成 man.config.bz2 ！"></a>此时 man.config 会变成 man.config.bz2 ！</h1><p>范例二：将范例一的档案内容读出来！<br>[root@linux tmp]# bzcat man.config.bz2</p>
<h1 id="此时屏幕上会显示-man-config-bz2-解压缩之后的档案内容！！"><a href="#此时屏幕上会显示-man-config-bz2-解压缩之后的档案内容！！" class="headerlink" title="此时屏幕上会显示 man.config.bz2 解压缩之后的档案内容！！"></a>此时屏幕上会显示 man.config.bz2 解压缩之后的档案内容！！</h1><p>范例三：将范例一的档案解压缩<br>[root@linux tmp]# bzip2 -d man.config.bz2<br>范例四：将范例三解开的 man.config 用最佳的压缩比压缩，并保留原本的档案<br>[root@linux tmp]# bzip2 -9 -c man.config &gt; man.config.bz2<br>tar：<br>[root@linux ~]# tar [-cxtzjvfpPN] 档案与目录 ….<br>参数：<br>-c ：建立一个压缩档案的参数指令(create 的意思)；<br>-x ：解开一个压缩档案的参数指令！<br>-t ：查看 tarfile 里面的档案！<br>特别注意，在参数的下达中， c/x/t 仅能存在一个！不可同时存在！<br>因为不可能同时压缩与解压缩。<br>-z ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩？<br>-j ：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩？<br>-v ：压缩的过程中显示档案！这个常用，但不建议用在背景执行过程！<br>-f ：使用档名，请留意，在 f 之后要立即接档名喔！不要再加参数！<br>例如使用『 tar -zcvfP tfile sfile』就是错误的写法，要写成<br>『 tar -zcvPf tfile sfile』才对喔！<br>-p ：使用原档案的原来属性（属性不会依据使用者而变）<br>-P ：可以使用绝对路径来压缩！<br>-N ：比后面接的日期(yyyy/mm/dd)还要新的才会被打包进新建的档案中！<br>–exclude FILE：在压缩的过程中，不要将 FILE 打包！<br>范例：<br>范例一：将整个 /etc 目录下的档案全部打包成为 /tmp/etc.tar<br>[root@linux ~]# tar -cvf /tmp/etc.tar /etc &lt;==仅打包，不压缩！<br>[root@linux ~]# tar -zcvf /tmp/etc.tar.gz /etc &lt;==打包后，以 gzip 压缩<br>[root@linux ~]# tar -jcvf /tmp/etc.tar.bz2 /etc &lt;==打包后，以 bzip2 压缩</p>
<h1 id="特别注意，在参数-f-之后的档案档名是自己取的，我们习惯上都用-tar-来作为辨识。"><a href="#特别注意，在参数-f-之后的档案档名是自己取的，我们习惯上都用-tar-来作为辨识。" class="headerlink" title="特别注意，在参数 f 之后的档案档名是自己取的，我们习惯上都用 .tar 来作为辨识。"></a>特别注意，在参数 f 之后的档案档名是自己取的，我们习惯上都用 .tar 来作为辨识。</h1><h1 id="如果加-z-参数，则以-tar-gz-或-tgz-来代表-gzip-压缩过的-tar-file-～"><a href="#如果加-z-参数，则以-tar-gz-或-tgz-来代表-gzip-压缩过的-tar-file-～" class="headerlink" title="如果加 z 参数，则以 .tar.gz 或 .tgz 来代表 gzip 压缩过的 tar file ～"></a>如果加 z 参数，则以 .tar.gz 或 .tgz 来代表 gzip 压缩过的 tar file ～</h1><h1 id="如果加-j-参数，则以-tar-bz2-来作为附档名啊～"><a href="#如果加-j-参数，则以-tar-bz2-来作为附档名啊～" class="headerlink" title="如果加 j 参数，则以 .tar.bz2 来作为附档名啊～"></a>如果加 j 参数，则以 .tar.bz2 来作为附档名啊～</h1><h1 id="上述指令在执行的时候，会显示一个警告讯息："><a href="#上述指令在执行的时候，会显示一个警告讯息：" class="headerlink" title="上述指令在执行的时候，会显示一个警告讯息："></a>上述指令在执行的时候，会显示一个警告讯息：</h1><h1 id="『tar-Removing-leading-‘-from-member-names』那是关于绝对路径的特殊设定。"><a href="#『tar-Removing-leading-‘-from-member-names』那是关于绝对路径的特殊设定。" class="headerlink" title="『tar: Removing leading `/‘ from member names』那是关于绝对路径的特殊设定。"></a>『tar: Removing leading `/‘ from member names』那是关于绝对路径的特殊设定。</h1><p>范例二：查阅上述 /tmp/etc.tar.gz 档案内有哪些档案？<br>[root@linux ~]# tar -ztvf /tmp/etc.tar.gz</p>
<h1 id="由于我们使用-gzip-压缩，所以要查阅该-tar-file-内的档案时，"><a href="#由于我们使用-gzip-压缩，所以要查阅该-tar-file-内的档案时，" class="headerlink" title="由于我们使用 gzip 压缩，所以要查阅该 tar file 内的档案时，"></a>由于我们使用 gzip 压缩，所以要查阅该 tar file 内的档案时，</h1><h1 id="就得要加上-z-这个参数了！这很重要的！"><a href="#就得要加上-z-这个参数了！这很重要的！" class="headerlink" title="就得要加上 z 这个参数了！这很重要的！"></a>就得要加上 z 这个参数了！这很重要的！</h1><p>范例三：将 /tmp/etc.tar.gz 档案解压缩在 /usr/local/src 底下<br>[root@linux ~]# cd /usr/local/src<br>[root@linux src]# tar -zxvf /tmp/etc.tar.gz</p>
<h1 id="在预设的情况下，我们可以将压缩档在任何地方解开的！以这个范例来说，"><a href="#在预设的情况下，我们可以将压缩档在任何地方解开的！以这个范例来说，" class="headerlink" title="在预设的情况下，我们可以将压缩档在任何地方解开的！以这个范例来说，"></a>在预设的情况下，我们可以将压缩档在任何地方解开的！以这个范例来说，</h1><h1 id="我先将工作目录变换到-usr-local-src-底下，并且解开-tmp-etc-tar-gz-，"><a href="#我先将工作目录变换到-usr-local-src-底下，并且解开-tmp-etc-tar-gz-，" class="headerlink" title="我先将工作目录变换到 /usr/local/src 底下，并且解开 /tmp/etc.tar.gz ，"></a>我先将工作目录变换到 /usr/local/src 底下，并且解开 /tmp/etc.tar.gz ，</h1><h1 id="则解开的目录会在-usr-local-src-etc-呢！另外，如果您进入-usr-local-src-etc"><a href="#则解开的目录会在-usr-local-src-etc-呢！另外，如果您进入-usr-local-src-etc" class="headerlink" title="则解开的目录会在 /usr/local/src/etc 呢！另外，如果您进入 /usr/local/src/etc"></a>则解开的目录会在 /usr/local/src/etc 呢！另外，如果您进入 /usr/local/src/etc</h1><h1 id="则会发现，该目录下的档案属性与-etc-可能会有所不同喔！"><a href="#则会发现，该目录下的档案属性与-etc-可能会有所不同喔！" class="headerlink" title="则会发现，该目录下的档案属性与 /etc/ 可能会有所不同喔！"></a>则会发现，该目录下的档案属性与 /etc/ 可能会有所不同喔！</h1><p>范例四：在 /tmp 底下，我只想要将 /tmp/etc.tar.gz 内的 etc/passwd 解开而已<br>[root@linux ~]# cd /tmp<br>[root@linux tmp]# tar -zxvf /tmp/etc.tar.gz etc/passwd</p>
<h1 id="我可以透过-tar-ztvf-来查阅-tarfile-内的文件名称，如果单只要一个档案，"><a href="#我可以透过-tar-ztvf-来查阅-tarfile-内的文件名称，如果单只要一个档案，" class="headerlink" title="我可以透过 tar -ztvf 来查阅 tarfile 内的文件名称，如果单只要一个档案，"></a>我可以透过 tar -ztvf 来查阅 tarfile 内的文件名称，如果单只要一个档案，</h1><h1 id="就可以透过这个方式来下达！注意到！-etc-tar-gz-内的根目录-是被拿掉了！"><a href="#就可以透过这个方式来下达！注意到！-etc-tar-gz-内的根目录-是被拿掉了！" class="headerlink" title="就可以透过这个方式来下达！注意到！ etc.tar.gz 内的根目录 / 是被拿掉了！"></a>就可以透过这个方式来下达！注意到！ etc.tar.gz 内的根目录 / 是被拿掉了！</h1><p>范例五：将 /etc/ 内的所有档案备份下来，并且保存其权限！<br>[root@linux ~]# tar -zcvpf /tmp/etc.tar.gz /etc</p>
<h1 id="这个-p-的属性是很重要的，尤其是当您要保留原本档案的属性时！"><a href="#这个-p-的属性是很重要的，尤其是当您要保留原本档案的属性时！" class="headerlink" title="这个 -p 的属性是很重要的，尤其是当您要保留原本档案的属性时！"></a>这个 -p 的属性是很重要的，尤其是当您要保留原本档案的属性时！</h1><p>范例六：在 /home 当中，比 2005/06/01 新的档案才备份<br>[root@linux ~]# tar -N ‘2005/06/01’ -zcvf home.tar.gz /home<br>范例七：我要备份 /home, /etc ，但不要 /home/dmtsai<br>[root@linux ~]# tar –exclude /home/dmtsai -zcvf myfile.tar.gz /home/* /etc<br>范例八：将 /etc/ 打包后直接解开在 /tmp 底下，而不产生档案！<br>[root@linux ~]# cd /tmp<br>[root@linux tmp]# tar -cvf - /etc | tar -xvf -</p>
<h1 id="这个动作有点像是-cp-r-etc-tmp-啦～依旧是有其有用途的！"><a href="#这个动作有点像是-cp-r-etc-tmp-啦～依旧是有其有用途的！" class="headerlink" title="这个动作有点像是 cp -r /etc /tmp 啦～依旧是有其有用途的！"></a>这个动作有点像是 cp -r /etc /tmp 啦～依旧是有其有用途的！</h1><h1 id="要注意的地方在于输出档变成-而输入档也变成-，又有一个-存在～"><a href="#要注意的地方在于输出档变成-而输入档也变成-，又有一个-存在～" class="headerlink" title="要注意的地方在于输出档变成 - 而输入档也变成 - ，又有一个 | 存在～"></a>要注意的地方在于输出档变成 - 而输入档也变成 - ，又有一个 | 存在～</h1><h1 id="这分别代表-standard-output-standard-input-与管线命令啦！"><a href="#这分别代表-standard-output-standard-input-与管线命令啦！" class="headerlink" title="这分别代表 standard output, standard input 与管线命令啦！"></a>这分别代表 standard output, standard input 与管线命令啦！</h1><h1 id="这部分我们会在-Bash-shell-时，再次提到这个指令跟大家再解释啰！"><a href="#这部分我们会在-Bash-shell-时，再次提到这个指令跟大家再解释啰！" class="headerlink" title="这部分我们会在 Bash shell 时，再次提到这个指令跟大家再解释啰！"></a>这部分我们会在 Bash shell 时，再次提到这个指令跟大家再解释啰！</h1><p>这是一个多用途的压缩指令！刚刚我们提到的 compress 与 gzip 是可以适用在一个档案的压缩上面， 但是如果是要将一个目录压缩成一个档案呢？！这时该如何是好？！呵呵！ tar 就派上用场了！ tar 可以将整个目录或者是指定的档案都整合成一个档案！例如上面的范例一，他可以将 /etc 底下的档案全部整合成一个档案！同时， tar 可以配合 gzip (这个 gzip 的功能已经已经附加上 tar 里面去了) ，同时整合并压缩！<br>• 绝对路径与权限的问题<br>另外，需要注意的是，在使用的参数方面，有还有几个有用的参数需要来了解一番，亦即是 -p 与 -P 这两个！在我们的范例一当中，有提到一个警告讯息，那就是『 tar: Removing leading `/‘ from member names』 意思是说， tar 将 /etc 目录的那个 / 拿掉了！这是因为担心未来你在解开压缩的时候，会产生一些困扰， 因为在 tar 里面的档案如果是具有『绝对路径』的话，那么你解开的档案将会『一定』在该路径下也就是 /etc，而不是相对路径 (这里请用心的想一想！) 。 这样子的最大困扰是，万一有人拿走了你的这个档案，并且将该档案在他的系统上面解开！万一他的系统上面正巧也有 /etc 这个目录 (那当然是一定有的啊！)，哈哈！他的档案就会『正巧』被覆盖了！ 所以啰，在预设的情况中，如果是以『绝对路径』来建立打包档案，那么 tar 将会自动的将 / 拿掉！这是为了刚刚说明的『安全』为前提所做的默认值。好了！但是你就是要以绝对路径来建立打包的档案！那么就<br>加入 -P 这个参数吧 (请注意！是大写字符) ！这样就可以啦！<br>VIM退出命令<br>注意：这些命令前面都有一个冒号：<br>当编辑完文档，准备退出Vi返回到shell时，能够使用以下几种方法之一。<br>在命令模式中，连按两次大写字母Z，若当前编辑的文档曾被修改过，则Vi保存该文档后退出，返回到shell；若当前编辑的文档没被修改过，则Vi直接退出, 返回到shell。<br>在末行模式下，输入命令<br>:w<br>Vi保存当前编辑文档，但并不退出，而是继续等待用户输入命令。在使用w命令时，能够再给编辑文档起一个新的文档名。<br>:w newfile<br>此时Vi将把当前文档的内容保存到指定的newfile中，而原有文档保持不变。若newfile是个已存在的文档，则Vi在显示窗口的状态行给出提示信息：<br>File exists （use ! to override）<br>此时，若用户真的希望用文档的当前内容替换newfile中原有内容，可使用命令<br>:w! newfile<br>否则可选择另外的文档名来保存当前文档。<br>在末行模式下，输入命令<br>:q<br>系统退出Vi返回到shell。若在用此命令退出Vi时，编辑文档没有被保存，则Vi在显示窗口的最末行显示如下信息：<br>No write since last change （use ! to overrides）<br>提示用户该文档被修改后没有保存，然后Vi并不退出，继续等待用户命令。若用户就是不想保存被修改后的文档而要强行退出Vi时，可使用命令<br>:q!<br>Vi放弃所作修改而直接退到shell下。</p>
<p>在末行模式下，输入命令<br>:wq<br>Vi将先保存文档，然后退出Vi返回到shell。<br>在末行模式下，输入命令<br>:x<br>该命令的功能同命令模式下的ZZ命令功能相同。<br>vi：常用命令<br>如前所述，所谓的命令列或命令模式，就是在最下面一行没有显示 『–INSERT–』或者『–REPLACE–』 字样的时候。通常在命令列中的指令有下面几种：（注意，当按下 『:』 时，光标会自动移动到屏幕的最下面一行！）<br>一般模式： 移动光标的方法<br>h 或 向左方向键(←)<br>光标向左移动一个字符<br>j 或 向下方向键(↓)<br>光标向下移动一个字符<br>k 或 向上方向键(↑)<br>光标向上移动一个字符<br>l 或 向右方向键(→)<br>光标向右移动一个字符<br>如果想要进行多次移动的话，例如向下移动 30 行，可以使用 “30j” 或 “30↓” 的组合按键， 亦即加上想要进行的次数(数字)后，按下动作即可！<br>[Ctrl] + [f]<br>屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)<br>[Ctrl] + [b]<br>屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)<br>[Ctrl] + [d]<br>屏幕『向下』移动半页<br>[Ctrl] + [u]<br>屏幕『向上』移动半页<br>+<br>光标移动到非空格符的下一列<br>-<br>光标移动到非空格符的上一列<br>n<space><br>那个 n 表示『数字』，例如 20 。按下数字后再按空格键，光标会向右移动这一行的 n 个字符。例如 20<space> 则光标会向后面移动 20 个字符距离。<br>0<br>这是数字『 0 』：移动到这一行的最前面字符处 (常用)<br>$<br>移动到这一行的最后面字符处(常用)<br>H<br>光标移动到这个屏幕的最上方那一行<br>M<br>光标移动到这个屏幕的中央那一行<br>L<br>光标移动到这个屏幕的最下方那一行<br>G<br>移动到这个档案的最后一行(常用)<br>nG<br>n 为数字。移动到这个档案的第 n 行。例如 20G 则会移动到这个档案的第 20 行(可配合 :set nu)<br>gg<br>移动到这个档案的第一行，相当于 1G 啊！ (常用)<br>n<enter><br>n 为数字。光标向下移动 n 行(常用)<br>一般模式： 搜寻与取代<br>/word<br>向光标之下寻找一个字符串名称为 word 的字符串。例如要在档案内搜寻 vbird 这个字符串，就输入 /vbird 即可！ (常用)<br>?word<br>向光标之上寻找一个字符串名称为 word 的字符串。<br>n<br>这个 n 是英文按键。代表『重复前一个搜寻的动作』的意思。举例来说， 如果刚刚我们执行 /vbird 去向下搜寻 vbird 这个字符串，则按下 n 后，会向下继续搜寻下一个名称为 vbird 的字符串。如果是执行 ?vbird 的话，那么按下 n 则会向上继续搜寻名称为 vbird 的字符串！<br>N<br>这个 N 是英文按键。与 n 刚好相反，为『反向』进行前一个搜寻动作。 例如 /vbird 后，按下 N 则表示『向上』搜寻 vbird 。<br>:n1,n2s/word1/word2/g<br>n1 与 n2 为数字。在第 n1 与 n2 行之间寻找 word1 这个字符串，并将该字符串取代为 word2 ！举例来说，在 100 到 200 行之间搜寻 vbird 并取代为 VBIRD 则： 『:100,200s/vbird/VBIRD/g』。(常用)<br>:1,$s/word1/word2/g<br>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！(常用)<br>:1,$s/word1/word2/gc<br>从第一行到最后一行寻找 word1 字符串，并将该字符串取代为 word2 ！且在取代前显示提示字符给使用者确认 (conform) 是否需要取代！(常用)<br>一般模式： 删除、复制与贴上<br>x, X<br>在一行字当中，x 为向后删除一个字符 (相当于 [del] 按键)， X 为向前删除一个字符(相当于 [backspace] 亦即是退格键) (常用)<br>nx<br>n 为数字，连续向后删除 n 个字符。举例来说，我要连续删除 10 个字符， 『10x』。<br>dd<br>删除游标所在的那一整列(常用)<br>ndd<br>n 为数字。删除光标所在的向下 n 列，例如 20dd 则是删除 20 列 (常用)<br>d1G<br>删除光标所在到第一行的所有数据<br>dG<br>删除光标所在到最后一行的所有数据<br>d$<br>删除游标所在处，到该行的最后一个字符<br>d0<br>那个是数字的 0 ，删除游标所在处，到该行的最前面一个字符<br>yy<br>复制游标所在的那一行(常用)<br>nyy<br>n 为数字。复制光标所在的向下 n 列，例如 20yy 则是复制 20 列(常用)<br>y1G<br>复制光标所在列到第一列的所有数据<br>yG<br>复制光标所在列到最后一列的所有数据<br>y0<br>复制光标所在的那个字符到该行行首的所有数据<br>y$<br>复制光标所在的那个字符到该行行尾的所有数据<br>p, P<br>p 为将已复制的数据在光标下一行贴上，P 则为贴在游标上一行！ 举例来说，我目前光标在第 20 行，且已经复制了 10 行数据。则按下 p 后， 那 10 行数据会贴在原本的 20 行之后，亦即由 21 行开始贴。但如果是按下 P 呢？ 那么原本的第 20 行会被推到变成 30 行。 (常用)<br>J<br>将光标所在列与下一列的数据结合成同一列<br>c<br>重复删除多个数据，例如向下删除 10 行，[ 10cj ]<br>u<br>复原前一个动作。(常用)<br>[Ctrl]+r<br>重做上一个动作。(常用)<br>这个 u 与 [Ctrl]+r 是很常用的指令！一个是复原，另一个则是重做一次～ 利用这两个功能按键，您的编辑，嘿嘿！很快乐的啦！<br>.<br>不要怀疑！这就是小数点！意思是重复前一个动作的意思。 如果您想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)<br>进入编辑模式<br>i, I<br>插入：在目前的光标所在处插入输入之文字，已存在的文字会向后<br>退； 其中， i 为『从目前光标所在处插入』， I 为『在目前所在行的第一个非空格符处开始插入』。 (常用)<br>a, A<br>a 为『从目前光标所在的下一个字符处开始插入』， A 为『从光标所在行的最后一个字符处开始插入』。(常用)<br>o, O<br>这是英文字母 o 的大小写。o 为『在目前光标所在的下一行处插入新的一行』； O 为在目前光标所在处的上一行插入新的一行！(常用)<br>r, R<br>取代：r 会取代光标所在的那一个字符；R会一直取代光标所在的文字，直到按下 ESC 为止；(常用)<br>上面这些按键中，在 vi 画面的左下角处会出现『–INSERT–』或『–REPLACE–』的字样。 由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时， 一定要在左下角处看到 INSERT/REPLACE 才能输入喔！<br>Esc<br>退出编辑模式，回到一般模式中(常用)<br>指令列命令模式<br>:w<br>将编辑的数据写入硬盘档案中(常用)<br>:w!<br>若档案属性为『只读』时，强制写入该档案。不过，到底能不能写入， 还是跟您对该档案的档案权限有关啊！<br>:q<br>离开 vi (常用)<br>:q!<br>若曾修改过档案，又不想储存，使用 ! 为强制离开不储存档案。<br>注意一下啊，那个惊叹号 (!) 在 vi 当中，常常具有『强制』的意思～</enter></space></space></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/ambitionkingman/2018/03/07/operationsystem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wu Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://p4ucv3uvl.bkt.clouddn.com/avatar/godnaruto.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wuwei` Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/07/operationsystem/" itemprop="url">操作系统</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-07T23:16:28+08:00">
                2018-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><h4 id="操作系统：引导"><a href="#操作系统：引导" class="headerlink" title="操作系统：引导"></a>操作系统：引导</h4><p>标题：Windows系统引导文件(boot.ini)格式详解<br>2013-08-13 14:16:50</p>
<p>当我们在电脑中安装了多个操作系统之后，每次启动计算机时都会出现一个系统引导菜单，在此选择需要进入的系统后回车即可。</p>
<p>Windows操作系统主要依赖Boot.ini文件来确定计算机在引导过程中显示的可供选取的操作系统类别。系统安装时，会在引导分区的根目录中建立引导菜单文件 boot.ini。boot.ini 在缺省状态下被设定为隐含和系统文件属性，并且被标识为只读文件。使用它我们可以轻松对电脑中的多系统进行引导，还可以通过该引导文件，设置个性化的启动菜单。<br>一、boot.ini文件格式 当电脑开机时，计算机将根据此引导菜单文件启动相应的操作系统。如果是多操作系统，可会提示用户选择要启动哪一个操作系统。boot.init文件示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[boot loader]</span><br><span class="line">timeout=30</span><br><span class="line">default=multi(0)disk(0)rdisk(0)partition(2)\WINNT</span><br><span class="line"></span><br><span class="line">[operating systems]</span><br><span class="line">multi(0)disk(0)rdisk(0)partition(2)\WINNT=&quot;Microsoft Windows XP Professional&quot; /fastdetect</span><br><span class="line">multi(0)disk(0)rdisk(1)partition(1)\WINNT=&quot;Microsoft Windows NT Sever&quot; /fastdetect</span><br><span class="line">C:\=&quot;Microsoft Windows&quot;</span><br><span class="line">C:\bootsect.bin=&quot;linux&quot;</span><br></pre></td></tr></table></figure></p>
<p>这里，大家可以看到boot.ini文件分为两部分，[boot loader]和[operating systems]。 [boot loader]<br>timeout=???</p>
<p>timeout=??? 表示在出现多操作系统引导时。选择菜单滞留的时间，单位为妙。默认为30秒。时间定义不同值时含义如下：</p>
<p>1&gt;1-999：时间范围有效，多操作系统时，在显示选择菜单后，如果用户不做任何操作，则菜单在这个时间后消息，并进入默认的操作系统。<br>2&gt;0    ：不会出现多操作系统选择菜单。默认进入第一个操作系统（即[operating systems]下面的第一个操作系统）。<br>3&gt;负数或者大于999：系统认为此值无效，在显示选择菜单后，如果用户不做任何操作，则一直显示该菜单。</p>
<p>default=???</p>
<p>default=???表示默认进入的操作系统的路径，其中???的格式为[operating systems]下面等号之前的部分。大概有两种情况：win9x系列（95、98、ME）和NT系列(NT4.0、WIN2000、WINXP)。前一种，由于Active区的问题，基本上为C:\ 后一种，遵从ARC命名规则。<br>[operating systems]<br>这部分的每一行都代表引导一个操作系统，每一行可分四部分：等号之前、等号、等号之后、/???</p>
<p>multi(0)disk(0)rdisk(0)partition(2)\WINNT=”Microsoft Windows 2000 Professional” /fastdetect</p>
<p>蓝色背景部分表示操作系统的引导分区所在的设备路径，它遵循ARC命名规则。<br>绿色背景部分表示操作系统选择菜单中显示的操作系统的名字，随便你在英文双引号里添什么都可以。<br>橙色背景部分表示操作操作系统的启动参数，/fastdetect，表示快速引导。/console 表示虚拟控制台等，参数和前面的内容用空格分隔。</p>
<p>win9x系列（95、98、ME）通常用以下格式命名：<br>C:\=”Microsoft Windows”<br>二、boot.ini文件在哪里<br>Boot.ini文件通常位于C盘根目录下，是一个隐藏文件，你可以通过以下操作显示隐藏文件“工具”—“文件夹选项”—“查看”菜单上选择“显示隐含文件和文件夹”。<br>也可以在“运行”中输入“c:\boot.ini”打开该文件。<br>三、修改boot.ini文件的方法<br>更改boot.int前，右击boot.int—“属性”，去掉“只读” 。</p>
<ol>
<li>使用记事本或文本编辑器直接编辑</li>
<li>借助命令行工具bootcfg.exe对Boot.ini文件执行编辑操作（在cmd窗口中，输入bootcfg可以查询当前boot.ini文件的详情，输入bootcfg /?来查看相关参数功能）<br>四、设置个性化的启动菜单 1.自定义延迟时间<br>　　延迟时间是系统启动引导菜单后在设定的延迟时间内用户没有进行任何操作时，进入默认的操作系统。<br> 打开Boot.ini文件，将timeout=???的等号后面直接输入要延迟的时间，单位为秒，更改后保存文件即可。<br>　　还可以在“系统配置实用程序”中对其进行修改。在“开始/运行”中键入“msconfig”命令，在弹出的“系统配置实用程序”中单击“Boot.ini”标签，在“Boot.ini”界面中的“超时XX秒”项中输入需要的延时时间即可。<br>2.自定义显示内容<br>　　在多系统启动时，有一个操作系统选择列表，这些列表显示的是电脑中所有操作系统的名称，如：Microsoft Windows XP Professional。<br>　　我们可以对这些显示内容进行修改，加载一些个性化的设置。<br>　　打开“boot.ini”文件，找到[operating systems]字段，该字段是显示当前操作系统列表，<br>　　其格式为multi(0)disk(0)rdisk(0)partition(3)\WINDOWS=”Microsoft Windows XP Professional” /fastdetect<br>　　后面引号中的部分就是系统启动时显示的内容，只要将引号中的这些内容更改为自己需要的文字即可。<br>3.定义默认启动系统<br>　　装了多系统后，boot.ini会将其中一个系统设置为默认启动系统，如Windows XP，在超过延迟时间后将自动引导默认的系统启动。<br>　　我们可以根据需要将默认的启动系统更改为其它的系统（如Windows 98），如果不想直接修改boot.ini文件的话，可以这样做：<br>　　右键单击“我的电脑”，选择“属性”，在系统属性对话框中单击“高级”选项，随后在下面的“启动和故障恢复”项中选择“设置”按钮，弹出一个“启动和故障恢复”对话框，单击“系统启动”项中的默认操作系统下拉菜单，选择一个需要的系统，单击“确定”即可；<br>　　也可以在“系统配置实用程序”中进行设置，选中想要设为默认的操作系统，点击下面的“设为默认”即可。<br>4.加载启动参数，更改启动画面<br>　　boot.ini在引导多系统启动时提供了很多的参数命令，这些启动参数可以得到不同的启动效果。<br>　　boot.ini在默认的情况下加载的是/fastdetect参数，表示启动时不检查串行口和并行口。<br>　　其实我们可以更改为其它参数，更改时首先在“boot.ini”中选择需要更改的系统列表，随后将该系统中的参数/fastdetect改为相应的参数值即可。以后再启动该系统就会加载一些设置信息或画面。我们以可以在“系统配置实用程序”中对一些参数进行设置，切换到“boot.ini”选项，先选中需要更改的系统，随后在“启动选项”下端勾选需要的启动参数即可,此对几个常用参数加以说明：<br>　　SAFEBOOT：安全启动，只启动HKLM\System\CurrentControlSetControl\SafeBoot中的驱动程序和服务，其后可跟三个参数Minimal、Network或Dsrepair。<br>　　Minimal和Network允许在网络连接下启动系统;Dsrepair要求系统从备份设备中调入活动目录的设置,还有一个选项是Minimal（AlternateShell），它让系统调入由HKLM\System\CurrentControlSetSafeBoot\AlternateShell指定的SHELL程序，而不使用默认的Explorer。<br>　　/NOGUIBOOT:不加载VGA驱动程序，也就不会显示启动过程和失败时的蓝屏信息。<br>　　/BOOTLOG：将日志写入Nnbtlog.txt文件。<br>　　/BASEVIDEO：使用标准VGA方式启动，这种方式主要用于显示驱动程序失效时。<br>　　/SOS：在调入驱动程序名时显示它的名称，因驱动问题而无法启动时使用比较好。<br>五、boot.ini文件丢失怎么办？<br>1.通过手动在C盘创建一个boot.ini文件，一般的XP下面的boot.ini文件为：</li>
</ol>
<p>　　[boot loader]<br>　　timeout=10<br>　　default=multi(0)disk(0)rdisk(0)partition(1)\WINDOWS<br>　　[operating systems]<br>　　multi(0)disk(0)rdisk(0)partition(1)\WINDOWS=”Microsoft Windows XP Professional” /noexecute=optin /fastdetect /usepmtimer</p>
<p>　　然后把此文件保存为boot.ini文件即可。<br>2.把C:\Windows\pss下的boot.ini.backup复制到C盘下，去掉.backup扩展名即可。</p>
<p>windows事件查看器，当软件，服务，程序启动不了，或报错可以来瞄一眼。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/ambitionkingman/2018/03/07/shortname/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wu Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://p4ucv3uvl.bkt.clouddn.com/avatar/godnaruto.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wuwei` Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/07/shortname/" itemprop="url">兴趣爱好之英文缩写</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-07T23:13:13+08:00">
                2018-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="兴趣爱好之英文缩写"><a href="#兴趣爱好之英文缩写" class="headerlink" title="兴趣爱好之英文缩写"></a>兴趣爱好之英文缩写</h3><h4 id="WSDL"><a href="#WSDL" class="headerlink" title="WSDL"></a>WSDL</h4><blockquote>
<p>网络服务描述语言是Web Service的描述语言，它包含一系列描述某个web service的定义</p>
</blockquote>
<p>Web Services Description Language</p>
<h4 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h4><blockquote>
<p>简单对象访问协议是交换数据的一种协议规范，是一种轻量的、简单的、基于XML（标准通用标记语言下的一个子集）的协议，它被设计成在WEB上交换结构化的和固化的信息</p>
</blockquote>
<p>Simple Object Access Protocol</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/ambitionkingman/2018/03/07/usefull_open_source/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wu Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://p4ucv3uvl.bkt.clouddn.com/avatar/godnaruto.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wuwei` Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/07/usefull_open_source/" itemprop="url">常用开源框架</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-07T23:09:08+08:00">
                2018-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="常用开源框架"><a href="#常用开源框架" class="headerlink" title="常用开源框架"></a>常用开源框架</h2><h4 id="数据库版本控制"><a href="#数据库版本控制" class="headerlink" title="数据库版本控制"></a>数据库版本控制</h4><p>flyway</p>
<h4 id="据说是效率最高的数据库连接池"><a href="#据说是效率最高的数据库连接池" class="headerlink" title="据说是效率最高的数据库连接池"></a>据说是效率最高的数据库连接池</h4><p>hikari 据说效率最高</p>
<h4 id="apache-BeanUtils"><a href="#apache-BeanUtils" class="headerlink" title="apache BeanUtils"></a>apache BeanUtils</h4><p>maven 引入方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">apache BeanUtils  </span><br><span class="line">&lt;dependency&gt;  </span><br><span class="line">  &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;  </span><br><span class="line">   &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;  </span><br><span class="line">  &lt;version&gt;1.8.3&lt;/version&gt;  </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<h4 id="apache-httpclient"><a href="#apache-httpclient" class="headerlink" title="apache httpclient"></a>apache httpclient</h4><p>maven 引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;httpclient&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.5.3&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/ambitionkingman/2018/03/07/mysql/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wu Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://p4ucv3uvl.bkt.clouddn.com/avatar/godnaruto.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wuwei` Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/07/mysql/" itemprop="url">mysql笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-07T22:59:40+08:00">
                2018-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Mysql-笔记"><a href="#Mysql-笔记" class="headerlink" title="Mysql 笔记"></a>Mysql 笔记</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ol>
<li>指定字符集创建数据库：</li>
</ol>
<h4 id="UTF8编码"><a href="#UTF8编码" class="headerlink" title="UTF8编码:"></a>UTF8编码:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE `test2` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;</span><br></pre></td></tr></table></figure>
<h4 id="GBK编码"><a href="#GBK编码" class="headerlink" title="GBK编码:"></a>GBK编码:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database test2 DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ci;</span><br></pre></td></tr></table></figure>
<p>MYSQL：<br>mysql的四种启动方式:<br>1、mysqld<br>启动mysql服务器:./mysqld –defaults-file=/etc/my.cnf –user=root<br>客户端连接:<br>mysql –defaults-file=/etc/my.cnf<br>or<br>mysql -S /tmp/mysql.sock</p>
<p>2、mysqld_safe<br>启动mysql服务器:./mysqld_safe –defaults-file=/etc/my.cnf –user=root &amp;<br>客户端连接:<br>mysql –defaults-file=/etc/my.cnf<br>or<br>mysql -S /tm/mysql.sock</p>
<p>3、mysql.server<br>cp -v /usr/local/mysql/support-files/mysql.server /etc/init.d/<br>chkconfig –add mysql.server<br>启动mysql服务器:service mysql.server {start|stop|restart|reload|force-reload|status}<br>客户端连接:同1、2</p>
<p>4、mysqld_multi<br>mkdir $MYSQL_BASE/data2<br>cat &lt;<-eof>&gt; /etc/my.cnf<br>[mysqld_multi]<br>mysqld    = /usr/local/mysql/bin/mysqld_safe<br>mysqladmin = /user/local/mysql/bin/mysqladmin<br>user = mysqladmin<br>password = mysqladmin</-eof></p>
<p>[mysqld3306]<br>port            = 3306<br>socket          = /tmp/mysql3306.sock<br>pid-file    = /tmp/mysql3306.pid<br>skip-external-locking<br>key_buffer_size = 16M<br>max_allowed_packet = 1M<br>table_open_cache = 64<br>sort_buffer_size = 512K<br>net_buffer_length = 8K<br>read_buffer_size = 256K<br>read_rnd_buffer_size = 512K<br>myisam_sort_buffer_size = 8M<br>basedir        = /usr/local/mysql<br>datadir        = /usr/local/mysql/data</p>
<p>[mysqld3307]<br>port            = 3307<br>socket          = /tmp/mysql3307.sock<br>pid-file    = /tmp/mysql3307.pid<br>skip-external-locking<br>key_buffer_size = 16M<br>max_allowed_packet = 1M<br>table_open_cache = 64<br>sort_buffer_size = 512K<br>net_buffer_length = 8K<br>read_buffer_size = 256K<br>read_rnd_buffer_size = 512K<br>myisam_sort_buffer_size = 8M<br>basedir        = /usr/local/mysql<br>datadir        = /usr/local/mysql/data2<br>EOF</p>
<p>#mysql -S /tmp/mysql3306.sock<br>mysql&gt;GRANT SHUTDOWN ON <em>.</em> TO ‘mysqladmin‘@’localhost’ identified by ‘mysqladmin’ with grant option;</p>
<p>#mysql -S /tmp/mysql3307.sock<br>mysql&gt;GRANT SHUTDOWN ON <em>.</em> TO ‘mysqladmin‘@’localhost’ identified by ‘mysqladmin’ with grant option;</p>
<p>启动mysql服务器:./mysqld_multi –defaults-file=/etc/my.cnf start 3306-3307<br>关闭mysql服务器:mysqladmin shutdown</p>
<p>MYSQL数据库编码乱的问题，导致dna基础数据混乱，修改mysql数据库编码。<br>5.6以后没有my.ini配置文件，默认的编码坑爹。<br>自行创建my.ini从my-defaults.ini拷贝加入如下代码，可修改字符<br>[client]<br> default-character-set=gbk<br>[mysqld]<br>character-set-server=gbk</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/ambitionkingman/2018/03/07/oracle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wu Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://p4ucv3uvl.bkt.clouddn.com/avatar/godnaruto.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wuwei` Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/07/oracle/" itemprop="url">Oracle 学习笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-07T22:54:28+08:00">
                2018-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Oracle-学习笔记"><a href="#Oracle-学习笔记" class="headerlink" title="Oracle 学习笔记"></a>Oracle 学习笔记</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ol>
<li><p>创建用户以及表空间：</p>
<ul>
<li><p>创建临时表空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create temporary tablespace user_temp</span><br><span class="line">tempfile &apos;D:\oracle\oradata\Oracle9i\user_temp.dbf&apos;</span><br><span class="line">size 50m</span><br><span class="line">autoextend on</span><br><span class="line">next 50m maxsize 20480m</span><br><span class="line">extent management local;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据表空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create tablespace test_data</span><br><span class="line">datafile &apos;D:\oracle\oradata\Oracle9i\user_data.dbf&apos;</span><br><span class="line">size 50m</span><br><span class="line">autoextend on</span><br><span class="line">next 50m maxsize 20480m</span><br><span class="line">extent management local;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<ul>
<li><p>删除表空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLESPACE tablespace_name INCLUDING CONTENTS AND DATAFILES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建用户并指定表空间</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create user username identified by password</span><br><span class="line">default tablespace user_data</span><br><span class="line">temporary tablespace user_temp;</span><br></pre></td></tr></table></figure>
</li>
<li><p>给用户授予权限</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grant connect,resource to username;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>以后以该用户登录，创建的任何数据库对象都属于user_temp 和user_data表空间，这就不用在每创建一个对象给其指定表空间。</p>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h4><p>谓词顺序：</p>
<ol>
<li>首先编码联接谓词，然后是本地谓词（单个表上的谓词），顺序与 FROM 子句中的已命名表的顺序相同。</li>
<li>过滤性较强的谓词应该放在过滤性较差的谓词前面，可能会有作用，因为优化器会重排谓词，所以在保证可读性的情况下，使用是可以的。</li>
<li>无论谓词的编码顺序如何，Stage 1 非索引谓词都按以下顺序应用：</li>
</ol>
<ul>
<li>等于谓词</li>
<li>范围谓词</li>
<li>列表和相似谓词</li>
</ul>
<p>注意事项：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from RG_BUSINESS_INFO rg where rg.DATATIME&gt;(select rg1.datatime from rg_business_info rg1 where rg1.recid =&apos;123&apos;);</span><br></pre></td></tr></table></figure></p>
<p>当子查询返回结果集为空，（0个结果）,where判断执行找不到结果，所以结果集返回为空。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select rg1.datatime from rg_business_info rg1 where rg1.recid =&apos;123&apos;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">select * from RG_BUSINESS_INFO rg where rg.DATATIME&gt;（select case when max(log.SYNDATE)is null then DATE&apos;1970-01-07&apos; else max(log.syndate) end as time from datasynlogtable  log）;</span><br></pre></td></tr></table></figure></p>
<p>当使用聚合函数时，子查询数据表中没值时，某些聚合函数返回null，因此可以使用case when 设置默认值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select   max(log.SYNDATE) from datasynlogtable  log;</span><br></pre></td></tr></table></figure></p>
<h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><p>聚合函数：一般会忽略空值。<br>当然对sum,max,min,avg等其他聚合函数都是如此。<br>1 .对于聚合函数，如果给定的值中存在空值的话，oracle将会直接忽略。<br>例如,对于scott的schema中有表emp;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select count(*) from emp;</span><br></pre></td></tr></table></figure></p>
<p>将会得到结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COUNT(*)  14</span><br></pre></td></tr></table></figure></p>
<p>但是我们注意到在Mgr列中有一列是空值，于是<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Select count(mgr) from emp;</span><br></pre></td></tr></table></figure></p>
<p>将会得到如下结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COUNT(MGR) 13</span><br></pre></td></tr></table></figure></p>
<h3 id="Pro-Oracle-sql学习笔记："><a href="#Pro-Oracle-sql学习笔记：" class="headerlink" title="Pro Oracle sql学习笔记："></a>Pro Oracle sql学习笔记：</h3><h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><p>标量子查询：当使用另一个SELECT语句来生成结果中某一列的值时，这个查询只能返回一行一列的值，这种类型的查询叫标量子查询。（注意）：标量子查询在结果集中的每一行结果产生时都要执行一遍。<br>DISTINCT：DISTINCT子句用来在其他子句执行完之后从结果集中去除重复的行。<br>排序是查询过程中开销相当大的一个处理步骤，尤其是当结果集非常大的时候。<br>MERGE : 可以按条件获取要更新活插入到表中的数据行。<br>ORACLE架构基础：<br>SGA共享池：共享池是Oracle缓存程序数据的地方。共享池中存储这些语句的地方称为库告诉缓存。<br>用一个sql更新多个字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sqlserver：</span><br><span class="line">    update A set A.c1=B.c1,A.c2=B.c2 from B where A.xx=B.xx and ...;</span><br><span class="line">Oracle：</span><br><span class="line">    update a set (c1,c2) =(select c1,c2 from b where a.xx=b.xx) where ...;</span><br></pre></td></tr></table></figure></p>
<h4 id="已知字段查找所在的表"><a href="#已知字段查找所在的表" class="headerlink" title="已知字段查找所在的表"></a>已知字段查找所在的表</h4><p>–查找该用户下(其他表如果有访问权限也算)有备注的字段中某个字段所在的表<br>SELECT <em><br>  FROM ALL_COL_COMMENTS<br> where column_name = ‘BBLX’<br>    or column_name = ‘bblx’;<br>–查找当前用户下某个字段所属的表<br>select </em><br>  from user_tab_columns t<br> where t.COLUMN_NAME = ‘BOOK_FLAG’<br>     or t.COLUMN_NAME = ‘book_flag’;  </p>
<p> –在整个库查找某个字段所在的表<br> select ‘所在的表名 = ‘ || a.name||’, 字段名 = ‘ || b.name from sysobjects a<br>   join syscolumns b on a.id = b.id<br>  where b.name = ‘BOOK_FLAG’;  </p>
<h4 id="orcl卸载"><a href="#orcl卸载" class="headerlink" title="orcl卸载"></a>orcl卸载</h4><p>1.关闭oracle所有的服务</p>
<p>windows的服务管理器（Windows+R，然后输入services.msc快速打开任务管理器）中关闭（如果您没有打开过oracle任务，那就直接跳过吧！）</p>
<p>2.删除oracle在注册表中的信息</p>
<p>windows+R，然后输入regedit 打开注册表。</p>
<p>（1）删除Oracle在Windows中注册的各种服务</p>
<p>打开路径： HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\ ，删除该路径下的所有以oracle开始的服务名称。</p>
<p>（2）删除Oracle注册的安装信息</p>
<p>打开路径：HKEY_LOCAL_MACHINE\SOFTWARE\ORACLE ，删除该oracle目录。</p>
<p>（3）删除oracle注册的事件日志</p>
<p>打开路径： HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\Eventlog\Application，删除注册表的以oracle开头的所有项目。</p>
<p>3.删除环境变量path中关于oracle的内容。</p>
<p>鼠标右键右单击“我的电脑–&gt;属性–&gt;高级–&gt;环境变量–&gt;PATH 变量；删除Oracle在该值中的内容。注意:path中记录着一堆操作系统的目录，在windows中各个目录之间使用分号（;）隔开的，删除时注意。 建议：删除PATH环境变量中关于Oracle的值时，将该值全部拷贝到文本编辑器中，找到对应的Oracle的值，删除后，再拷贝修改的串，粘贴到PATH环境变量中，这样相对而言比较安全。</p>
<p>4.重新启动操作系统。<br>5.删除oracle安装目录</p>
<p>重启操作系统后各种Oracle相关的进程都不会加载了，这时删除Oracle_Home下的所有数据（Oracle_Home指Oracle程序的安装目录）；.删除C:\Program Files下oracle目录。 （该目录视Oracle安装所在路径而定）。</p>
<p>6.删除开始菜单下oracle项。</p>
<p>如： C:\Documents and Settings\All Users\「开始」菜单\程序\Oracle - Ora10g 不同的安装这个目录稍有不同。 如果不删除开始菜单下的Oracle相关菜单目录，没关系，这个不影响再次安装Oracle.当再次安装Oracle时，该菜单会被替换。</p>
<p>At present，You can say that you have made oracle got out of your computer 。。。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://github.com/ambitionkingman/2018/03/07/reference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wu Wei">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="http://p4ucv3uvl.bkt.clouddn.com/avatar/godnaruto.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wuwei` Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/07/reference/" itemprop="url">常用开源框架参考文档地址</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-07T22:52:16+08:00">
                2018-03-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="Spring-各个版本的文档"><a href="#Spring-各个版本的文档" class="headerlink" title="Spring 各个版本的文档"></a>Spring 各个版本的文档</h3><p><a href="https://docs.spring.io/spring/docs/" target="_blank" rel="noopener">Spring</a></p>
<h3 id="Spring-security-各个版本的文档"><a href="#Spring-security-各个版本的文档" class="headerlink" title="Spring security 各个版本的文档"></a>Spring security 各个版本的文档</h3><p><a href="https://docs.spring.io/spring-security/site/docs/" target="_blank" rel="noopener">Spring Security</a></p>
<h3 id="Spring-Boot-各个版本的文档"><a href="#Spring-Boot-各个版本的文档" class="headerlink" title="Spring Boot 各个版本的文档"></a>Spring Boot 各个版本的文档</h3><p><a href="https://docs.spring.io/spring-boot/docs/" target="_blank" rel="noopener">Spring Boot</a></p>
<h3 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h3><p><a href="http://www.mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">MyBatis中文文档</a></p>
<h3 id="Thymeleaf文档"><a href="#Thymeleaf文档" class="headerlink" title="Thymeleaf文档"></a>Thymeleaf文档</h3><p><a href="http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.pdf" target="_blank" rel="noopener">Thymeleaf文档 pdf</a><br><a href="http://www.thymeleaf.org/doc/tutorials/3.0/usingthymeleaf.html" target="_blank" rel="noopener">Thymeleaf文档 html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="http://p4ucv3uvl.bkt.clouddn.com/avatar/godnaruto.jpeg"
                alt="Wu Wei" />
            
              <p class="site-author-name" itemprop="name">Wu Wei</p>
              <p class="site-description motion-element" itemprop="description">Be a thoutghtfull programer,做一个有思想的程序猿。</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/ambitionkingman/" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:ambition_kingman@163.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/wu-wei-8-35/" target="_blank" title="zhihu">
                      
                        <i class="fa fa-fw fa-globe"></i>zhihu</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wu Wei</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
